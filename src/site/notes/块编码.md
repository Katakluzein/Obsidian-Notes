---
{"dg-publish":true,"permalink":"/块编码/","tags":["#量子模拟"]}
---

- [[Succinct Description and Efficient Simulation of Non-Markovian Open Quantum Systems\|Succinct Description and Efficient Simulation of Non-Markovian Open Quantum Systems]] 定义1
## 块编码的定义
**定义 1.** 令 A 为一个 n-量子比特算符。对于一个正实数 α > 0 和一个自然数 m，我们称一个 (n+m)-量子比特的幺正算符 U 是 A 的一个 **(α, m, ε)-块编码 (block-encoding)**，如果满足以下条件：

$$
\| A - \alpha (\langle 0|^{\otimes m} \otimes I_n) U (|0\rangle^{\otimes m} \otimes I_n) \| \le \varepsilon
$$

其中，$|0\rangle^{\otimes m}$ 是 m 个辅助量子比特（ancilla qubits）都处于 $|0\rangle$ 状态，而 $I_n$ 是作用于 n 个系统量子比特上的单位算符。范数 $\| \cdot \|$ 通常指谱范数。

---

### 解释

这个定义可能看起来很抽象，但其核心思想非常直观且强大。它是一种将**任意（通常是非幺正的）算符 A** “嵌入”到一个**更大、但却是幺正的算符 U** 中的标准方法。由于量子计算机的原生操作是幺正演化，这种编码方式为在量子计算机上“使用”非幺正算符 A 提供了桥梁。

我们可以从以下几个层面来理解这个定义：

#### 1. 核心思想：用幺正 U “代表” 非幺正 A

量子算法的核心是施加幺正变换。但我们经常需要处理的算符，比如哈密顿量 $H$（厄米算符）或投影算符（非幺正），本身并不是幺正的。块编码解决了这个问题，它说：

> 我们可以构造一个更大的幺正算符 U，只要我们**只关注这个 U 作用在特定子空间上的效果**，这个效果就等同于我们想要的算符 A（经过一个缩放因子 α）。

#### 2. “块编码”名称的由来（矩阵视角）

这个名字来自于将 U 看作一个大矩阵时的结构。U 作用于 n+m 个量子比特上，我们可以根据 m 个辅助比特的状态来将其分块。最重要的一块对应于辅助比特处于 $|00...0\rangle$ 状态。

如果我们将 U 的矩阵表示出来，它的左上角块（top-left block）正好是 $A/\alpha$：

$$
U = \begin{pmatrix}
A/\alpha & \dots \\
\dots & \dots
\end{pmatrix}
$$

这里的“左上角块”就是当输入和输出的辅助比特都处在 $|0\rangle^{\otimes m}$ 状态时，U 在 n 个系统量子比特上诱导的变换。

#### 3. 逐项解释定义中的数学表达式

让我们拆解公式 $\| A - \alpha (\langle 0|^{\otimes m} \otimes I_n) U (|0\rangle^{\otimes m} \otimes I_n) \| \le \varepsilon$：

*   **A**: 我们真正关心的 n-量子比特算符。这是我们的**目标**。
*   **U**: 一个 (n+m)-量子比特的幺正算符。这是我们可以在量子计算机上实际执行的**工具**。它作用于 n 个系统比特和 m 个辅助比特。
*   **m**: 所需的**辅助量子比特（ancilla qubits）的数量**。这些是临时的“工作”比特，帮助我们实现这个编码。
*   **$|0\rangle^{\otimes m} \otimes I_n$**: 这是一个算符，它将一个 n-量子比特态 $|\psi\rangle$ 映射到一个 (n+m)-量子比特态 $|0...0\rangle_m |\psi\rangle_n$。它描述了**准备**辅助比特到全零状态的过程。
*   **$(\langle 0|^{\otimes m} \otimes I_n) U (|0\rangle^{\otimes m} \otimes I_n)$**: 这部分是整个定义的核心。它的操作流程是：
    1.  **准备 (Prepare)**: 取 n 个系统比特，并附加 m 个处在 $|0\rangle$ 态的辅助比特。
    2.  **演化 (Evolve)**: 对这个 (n+m) 比特的组合系统施加幺正算符 U。
    3.  **投影 (Project)**: 演化结束后，将 m 个辅助比特**投影**回 $|0\rangle$ 态（或者说，后选择测量结果为全零的事件）。

    这个过程的净效应（conditioned on the ancillas starting and ending in the $|0\rangle$ state）是在 n 个系统比特上施加了一个等效的算符。这个等效算符就是 U 的左上角块，即 $A/\alpha$。

*   **$\alpha$ (Normalization Factor)**: 这是一个非常重要的**归一化（或缩放）因子**。因为 U 是幺正的，它的谱范数 $\|U\| = 1$。这意味着它的任何子块的谱范数都必须小于或等于 1。然而，我们想要编码的算符 A 的谱范数 $\|A\|$ 可能不为 1。因此，我们必须用一个足够大的 $\alpha$（通常要求 $\alpha \ge \|A\|$）来缩放 A，以确保 $\|A/\alpha\| \le 1$，这样它才可能成为一个幺正矩阵的块。这个 $\alpha$ 值也直接关系到算法的**成功概率**：投影辅助比特回 $|0\rangle$ 态的概率通常与 $1/\alpha^2$ 有关。$\alpha$ 越大，成功概率越低。

*   **$\varepsilon$ (Precision Parameter)**: 这个参数使得定义更加实用。在很多情况下，精确地构造 U (即 $\varepsilon = 0$) 可能非常困难或代价高昂。$\varepsilon$ 允许我们构造一个近似的 U，只要它与理想情况的误差在 $\varepsilon$ 范围内即可。

#### 总结与意义

**块编码**是一种强大的、标准化的接口，它将“能够使用算符 A”这个问题转化为了“能够调用幺正算符 U”这个问题。它的重要意义在于：

1.  **统一了输入模型**：无论 A 是稀疏的、是泡利算符的和，还是有其他结构，只要能为它构建一个高效的块编码 U，我们就可以用同样的方式来处理它。
2.  **赋能高级量子算法**：块编码是[[QSP\|量子信号处理]]、 **量子奇异值变换 (QSVT)** 等先进算法的基石。QSVT 能够获取 A 的块编码，并高效地构造出 $P(A)$ 的块编码，其中 P 是任意多项式。这使得模拟哈密顿动力学 ($e^{-iHt}$)、求解线性方程组 ($A^{-1}b$) 等一系列复杂任务成为可能，并且通常能达到最优的算法复杂度。

- [[用块编码实现任何算符\|用块编码实现任何算符]] 
## 与块编码相关的引理
我到底要怎么使用它呢？


### Lemma 3 稀疏矩阵的块编码(Block-encoding of sparse-access matrices)
这个引理分析了定义1中的$U$的构造构造方式及其==复杂度==。

现在我们按照论文 [arXiv:1806.01838](https://arxiv.org/abs/1806.01838) [[Quantum singular value transformation and beyond exponential improvements for quantum matrix arithmetics\|QSV beyond]]的思路来解释。

首先，我们复述引理内容，并明确一些细节。

**Lemma 48 ([Gilyén et al., 2018])**. 设 $A \in \mathbb{C}^{2^w \times 2^w}$ 是一个 $s_r$-行稀疏且 $s_c$-列稀疏的矩阵，每个元素的绝对值 $|A_{ij}| \le 1$。假设我们能访问以下预言机：
*   行预言机 $O_r: |i\rangle|k\rangle \mapsto |i\rangle|r_{ik}\rangle$ (给出第 $i$ 行第 $k$ 个非零元的列索引)。
*   列预言机 $O_c: |l\rangle|j\rangle \mapsto |c_{lj}\rangle|j\rangle$ (给出第 $j$ 列第 $l$ 个非零元的行索引)。
*   值预言机 $O_A: |i\rangle|j\rangle|0\rangle^b \mapsto |i\rangle|j\rangle|a_{ij}\rangle$ (给出 $A_{ij}$ 的 $b$-比特二进制表示)。

那么，我们可以实现一个 $A$ 的 $(\sqrt{s_r s_c}, w+3, \varepsilon)$-块编码。这个实现需要对 $O_r, O_c$ 各调用一次，对 $O_A$ 调用两次，并使用 $O(w + \log^{2.5}(s_r s_c / \varepsilon))$ 个基本门和 $O(b, \log^{2.5}(s_r s_c / \varepsilon))$ 个辅助比特。

---

### 直观讲解与核心思想

这篇论文的构造方法非常精妙，它**不是直接应用矩阵 A，而是通过制备两个特殊的量子态，并将 A 的矩阵元素编码在这两个态的内积中**。

**核心思想 (Gram 矩阵方法)**:
1.  **定义两个“态制备”幺正算符 $U_L$ 和 $U_R$**：
    *   $U_L$ 的作用是，对于任意行索引 $i$，制备一个与**第 $i$ 行**相关的量子态 $|\psi_i\rangle$。
    *   $U_R$ 的作用是，对于任意列索引 $j$，制备一个与**第 $j$ 列**相关的量子态 $|\phi_j\rangle$。
2.  **精巧的设计**: 这两个态 $|\psi_i\rangle$ 和 $|\phi_j\rangle$ 被设计成它们的**内积恰好等于矩阵元素 $A_{ij}$** (经过归一化)。
    $$
    \langle \psi_i | \phi_j \rangle = \frac{A_{ij}}{\sqrt{s_r s_c}}
    $$
3.  **构造块编码**: 众所周知，如果我们可以实现 $U_L$ 和 $U_R$，那么幺正算符 $U = U_L^\dagger U_R$ 的左上角块就是这两个态族构成的 Gram 矩阵 $G$，其元素为 $G_{ij} = \langle \psi_i | \phi_j \rangle$。因此，$U$ 就是 $A/\sqrt{s_r s_c}$ 的一个块编码。

现在，问题转化为了：**如何构造 $U_L$ 和 $U_R$？** 这正是预言机发挥作用的地方。

---

### 证明与电路构造 (严格版本)

我们将严格遵循论文中的构造。

**所需寄存器**:
*   一个**单比特**主 ancilla。
*   两个 $(w+1)$ 比特的寄存器。

总共需要 $1 + 2(w+1) = 2w+3$ 个量子比特。但通过寄存器复用，可以优化到 $w+3$ 个辅助比特。为清晰起见，我们先不考虑优化。

**1. 构造 $U_L$ 和 $U_R$**

这两个算符本身也是由更基础的单元构成的。

*   **构造 $V_L$**:
    *   $D_{s_r}$ 是一个在 $(w+1)$ 比特上创建均匀叠加态的幺正算符：$D_{s_r}|0\rangle = \frac{1}{\sqrt{s_r}}\sum_{k=1}^{s_r}|k\rangle$。
    *   $O_r$ 是行预言机。
    *   定义 $V_L = O_r(I_{w+1} \otimes D_{s_r})\text{SWAP}_{w+1}$。
    它的作用是：对于任意行索引 $|i\rangle$，
    $$
    V_L |0\rangle^{w+2} |i\rangle = V_L |0\rangle|0\rangle|i\rangle \mapsto |i\rangle \otimes \frac{1}{\sqrt{s_r}} \sum_{k=1}^{s_r} |r_{ik}\rangle
    $$
    (这里忽略了一些细节，但最终效果是这样)。

*   **构造 $V_R$**:
    类似地，使用列预言机 $O_c$ 和 $D_{s_c}$ 构造 $V_R$：
    $$
    V_R |0\rangle^{w+2} |j\rangle \mapsto \frac{1}{\sqrt{s_c}} \sum_{l=1}^{s_c} |c_{lj}\rangle \otimes |j\rangle
    $$

*   **引入矩阵值**:
    现在，我们使用值预言机 $O_A$ 来引入矩阵元素。定义 $U_R$ 如下：
    1.  施加 $V_R$。
    2.  对于得到的态 $\frac{1}{\sqrt{s_c}}\sum_l |c_{lj}\rangle|j\rangle$，查询 $O_A$ 得到 $a_{c_{lj}, j}$ 的值。
    3.  在一个新的单比特 ancilla 上，根据 $a_{c_{lj}, j}$ 的值施加一个受控操作。这个操作将 $|0\rangle$ 映射到 $a_{c_{lj}, j}|0\rangle + \sqrt{1-|a_{c_{lj}, j}|^2}|1\rangle$ (这是一个近似，需要更复杂的电路精确实现)。
    4.  反计算第 2 步，清空存储 $a_{c_{lj}, j}$ 的寄存器。

    最终，$U_R$ 的作用是：
    $$
    U_R : |0\rangle^{w+3}|j\rangle \mapsto \frac{1}{\sqrt{s_c}} \sum_{l=1}^{s_c} |c_{lj}\rangle|j\rangle \otimes (a_{c_{lj}, j}|0\rangle + \dots|1\rangle)
    $$
    $U_L$ 的构造完全类似，只是它操作在行索引上。
    $$
    U_L : |0\rangle^{w+3}|i\rangle \mapsto |i\rangle \otimes \frac{1}{\sqrt{s_r}} \sum_{k=1}^{s_r} |r_{ik}\rangle \otimes (|0\rangle + \dots)
    $$
    注意，在 $U_L$ 的构造中，受控旋转的幅度是 $1$，因为它不直接编码 $A$ 的值。

**2. 验证块编码**

现在我们来计算 $U = U_L^\dagger U_R$ 的左上角块。
$$
\langle 0 \dots 0 | U_L^\dagger U_R | 0 \dots 0 \rangle
$$
我们计算 $\langle i| (\langle 0 \dots 0 | U_L^\dagger) (U_R | 0 \dots 0 \rangle) |j\rangle$。

*   **计算 $U_R |0\rangle|j\rangle$**:
    正如上面所述， $U_R$ 作用在 $|0\rangle|j\rangle$ 上，会产生一个复杂的叠加态。我们只关心这个态中，那个单比特 ancilla 处于 $|0\rangle$ 的部分，因为最终我们要投影回全零状态。
    这个部分是：
    $$
    |\phi_j\rangle = \frac{1}{\sqrt{s_c}} \sum_{l=1}^{s_c} a_{c_{lj}, j} |c_{lj}\rangle |j\rangle
    $$
    (这是一个简化表示，态存在于一个更大的空间)。

*   **计算 $\langle i|\langle 0| U_L^\dagger$**:
    这等价于 $(U_L |0\rangle|i\rangle)^\dagger$。同样，我们只关心 ancilla 处于 $|0\rangle$ 的部分。$U_L$ 的构造与 $U_R$ 的不同之处在于，它施加的旋转幅度是 $1$，而不是 $a_{ij}$。
    $$
    U_L : |0\rangle|i\rangle \mapsto \frac{1}{\sqrt{s_r}} \sum_{k=1}^{s_r} |i\rangle |r_{ik}\rangle \otimes (|0\rangle + \sqrt{1-1^2}|1\rangle) = \frac{1}{\sqrt{s_r}} \sum_{k=1}^{s_r} |i\rangle |r_{ik}\rangle \otimes |0\rangle
    $$
    所以，我们得到：
    $$
    \langle \psi_i| = \frac{1}{\sqrt{s_r}} \sum_{k=1}^{s_r} \langle i| \langle r_{ik}|
    $$

*   **计算内积**:
    现在，我们计算 $\langle \psi_i | \phi_j \rangle$。
    $$
    \langle \psi_i | \phi_j \rangle = \left( \frac{1}{\sqrt{s_r}} \sum_{k=1}^{s_r} \langle i| \langle r_{ik}| \right) \left( \frac{1}{\sqrt{s_c}} \sum_{l=1}^{s_c} a_{c_{lj}, j} |c_{lj}\rangle |j\rangle \right)
    $$
    $$
    = \frac{1}{\sqrt{s_r s_c}} \sum_{k,l} a_{c_{lj}, j} \langle i | c_{lj} \rangle \langle r_{ik} | j \rangle
    $$
    当 $i=c_{lj}$ 且 $j=r_{ik}$ 时，内积不为零。这意味着我们求和的项，必须同时满足：
    1.  行索引是 $i$。
    2.  列索引是 $j$。
    3.  $A_{ij}$ 是一个非零元。

    当 $A_{ij} \neq 0$ 时，在 $k$ 的求和中，必然存在一个 $k_0$ 使得 $r_{ik_0}=j$；在 $l$ 的求和中，也必然存在一个 $l_0$ 使得 $c_{l_0j}=i$。所有其他的项都会因为正交性而消失。
    因此，求和中只剩下一项：
    $$
    = \frac{1}{\sqrt{s_r s_c}} a_{ij} \cdot 1 \cdot 1 = \frac{A_{ij}}{\sqrt{s_r s_c}}
    $$
    如果 $A_{ij}=0$，则 $a_{ij}=0$，内积自然为零。

**结论**:
我们已经证明，幺正算符 $U=U_L^\dagger U_R$ 的左上角块（在 $|i\rangle, |j\rangle$ 基下）的矩阵元为 $A_{ij}/\sqrt{s_r s_c}$。因此，$U$ 是 $A$ 的一个 $(\sqrt{s_r s_c}, \dots, \varepsilon)$-块编码。归一化因子 $\alpha = \sqrt{s_r s_c}$，这与引理中 $s=s_r=s_c$ 的特殊情况相符。

### 澄清几个关键点

*   **为什么是 $U_L^\dagger U_R$ 而不是别的组合？**
    这被称为“量子行走”范式。$U_L$ 和 $U_R$ 可以看作是定义在某个图上的行走算符的左右部分。它们的组合 $U_L^\dagger U_R$ 恰好给出了我们想要的块编码结构。
*   **A 是算符还是矩阵？**
    在这个语境下，两者可以互换。A 是一个线性算符，它在某个给定的计算基（$|i\rangle$）下的矩阵表示就是我们熟悉的矩阵 $(A_{ij})$。预言机提供的是矩阵元素的信息，而我们构造的块编码 $U$ 最终可以作用于任意的量子叠加态 $|\psi\rangle$，实现了算符 $A$ 的功能。
*   **与之前简化证明的区别**
    之前的简化证明试图在一个统一的步骤中完成位置查询和值应用，并且错误地将一个非幺正投影的后果混入了幺正演化中。而这个严格的构造，将过程分解为两个态制备 $U_L, U_R$，然后证明它们的组合 $U_L^\dagger U_R$ 给出了正确的 Gram 矩阵。这个方法是严谨且正确的。

这个构造是量子算法中处理稀疏矩阵的标准技术，其强大之处在于将复杂的矩阵操作问题转化为了相对简单的态制备问题。
### Lemma 4 的陈述

**Lemma 4**. 假设 $A := \sum_{j=1}^m y_j A_j \in \mathbb{C}^{2^n \times 2^n}$，其中 $A_j \in \mathbb{C}^{2^n \times 2^n}$ 且 $y_j > 0$ 对于所有 $j \in \{1, \dots, m\}$ 成立。令 $U_j$ 是 $A_j$ 的一个 $(a_j, a, \varepsilon)$-块编码。令 $B$ 是一个作用于 $b$ 个量子比特的幺正算符 (其中 $m \le 2^b - 1$)，它能够制备一个编码了系数的量子态，具体为：
$$
B|0\rangle^{\otimes b} = \sum_{j=1}^m \sqrt{\frac{a_j y_j}{s}} |j\rangle
$$
其中 $s = \sum_{j=1}^m y_j a_j$ 是总的归一化因子。
那么，我们可以实现 $A$ 的一个 $(\sum_j y_j a_j, a+b, \sum_j y_j a_j \varepsilon)$-块编码。这个实现需要**单次使用**一个受控的酉算符 $\sum_{j=0}^{m-1} |j\rangle\langle j| \otimes U_j + \dots$ (即 `SELECT` 算符)，以及**两次**对制备算符 $B$ (一次 $B$，一次 $B^\dagger$) 的调用。

*注意：论文中给出的引理是一个略微泛化的版本，但核心思想与此完全一致。*

---

#### 直观讲解与核心思想

这个引理是量子计算中最强大的基本工具之一，通常被称为**线性酉算符组合 (Linear Combination of Unitaries, LCU)** 的块编码版本。它回答了这样一个问题：

> 如果我已经知道如何将一堆“基础”算符 $A_j$ 封装在各自的幺正算符 $U_j$ 中，我如何构造一个封装了它们线性组合 $A = \sum y_j A_j$ 的新幺正算符？

**核心思想**是一个三步走的“**准备-选择-反准备**”协议，可以把它想象成一个“量子多路开关”：

1.  **准备 (PREPARE)**: 我们使用一个专门的幺正算符 $B$ 来创建一个“指令”叠加态。这个态的各个分支 $|j\rangle$ 对应于我们要选择的某个基础算符 $A_j$。每个分支的振幅 $\sqrt{a_j y_j / s}$ 被精确地设计，以编码该项在线性组合中的“权重”。这就像是把一个开关拨到所有可能位置的叠加态上，每个位置的概率由其重要性决定。

2.  **选择 (SELECT)**: 这是一个受控的幺正操作。它会检查“指令”寄存器的状态：如果寄存器处于 $|j\rangle$，它就在系统量子比特上施加对应的块编码酉算符 $U_j$。这个操作就像一个多路开关，根据控制信号，将输入连接到正确的“处理单元” $U_j$ 上。

3.  **反准备 (UNPREPARE)**: 在施加了 $U_j$ 之后，我们必须将“指令”寄存器恢复到其初始状态 $|0\rangle$。这通过施加 $B$ 的逆操作 $B^\dagger$ 来完成。这一步至关重要，它起到了**后选择 (post-selection)** 的作用。只有那些在 $B^\dagger$ 作用下能够成功返回到 $|0\rangle$ 状态的分支，才对应于我们想要的线性组合。所有其他的结果都被“过滤”掉了，进入了与初始状态正交的“垃圾”状态空间。

最终，这个协议的成功部分（即“指令”寄存器从 $|0\rangle$ 开始，最终又回到 $|0\rangle$）在系统上产生的净效应，正是施加了我们想要的算符 $A$，并带上了一个总的归一化因子 $s$。

---

#### 证明与电路构造

我们将构造一个新的幺正算符 $U_A$，并证明它的左上角块近似等于 $A/s$。

**所需寄存器**:
*   **系统寄存器** ($n$ 比特): 存储被操作的态。
*   **块编码辅助寄存器** ($a$ 比特): $U_j$ 使用的辅助比特。
*   **LCU 控制寄存器** ($b$ 比特): 存储“指令”叠加态 $|j\rangle$。

**电路构造**:
整个块编码 $U_A$ 由三个部分组成：
$U_A = (B^\dagger \otimes I_{2^a} \otimes I_{2^n}) \cdot W \cdot (B \otimes I_{2^a} \otimes I_{2^n})$
其中：
*   $B$ 是作用于 $b$ 个 LCU 控制比特的 **`PREPARE`** 算符。
*   $W = \sum_{j=1}^m |j\rangle\langle j| \otimes U_j$ 是 **`SELECT`** 算符（为了简化，我们忽略了超出 $m$ 范围的定义）。它由 LCU 控制比特控制，在系统和块编码辅助比特上施加 $U_j$。

**验证块编码**:
根据块编码的定义，我们需要计算 $U_A$ 的左上角块，即当所有辅助比特（包括 LCU 控制比特和块编码辅助比特）都处于 $|0\rangle$ 状态时，在系统上诱导的操作。
这个操作由下式给出：
$$
A_{\text{eff}} = (\langle 0|^{\otimes b} \otimes \langle 0|^{\otimes a} \otimes I_{2^n}) \cdot U_A \cdot (|0\rangle^{\otimes b} \otimes |0\rangle^{\otimes a} \otimes I_{2^n})
$$
让我们分步计算：

1.  **第一步 (PREPARE)**:
    $$ (B \otimes I) |0\rangle^{\otimes b} |0\rangle^{\otimes a} = \left( \sum_{j=1}^m \sqrt{\frac{a_j y_j}{s}} |j\rangle \right) |0\rangle^{\otimes a} $$

2.  **第二步 (SELECT)**:
    $$ W \left[ \left( \sum_{j=1}^m \sqrt{\frac{a_j y_j}{s}} |j\rangle \right) |0\rangle^{\otimes a} \right] = \sum_{j=1}^m \sqrt{\frac{a_j y_j}{s}} |j\rangle \otimes (U_j |0\rangle^{\otimes a}) $$
    这里，因为 $W$ 是受控操作，$|j\rangle$ 分支“选择”了 $U_j$ 进行作用。

3.  **第三步 (UNPREPARE & Project)**:
    我们用 $\langle 0|^{\otimes b} \otimes \langle 0|^{\otimes a}$ 从左侧投影上述结果。
    $$ (\langle 0|^{\otimes b} B^\dagger \otimes \langle 0|^{\otimes a}) \left[ \sum_{j=1}^m \sqrt{\frac{a_j y_j}{s}} |j\rangle \otimes (U_j |0\rangle^{\otimes a}) \right] $$
    我们知道 $\langle 0|^{\otimes b} B^\dagger = (B |0\rangle^{\otimes b})^\dagger = \left(\sum_{k=1}^m \sqrt{\frac{a_k y_k}{s}} |k\rangle\right)^\dagger = \sum_{k=1}^m \sqrt{\frac{a_k y_k}{s}} \langle k|$。
    代入上式，由于 $\langle k|j\rangle = \delta_{kj}$，求和合并：
    $$
    A_{\text{eff}} = \sum_{j=1}^m \left( \sqrt{\frac{a_j y_j}{s}} \right)^2 (\langle 0|^{\otimes a} U_j |0\rangle^{\otimes a}) = \sum_{j=1}^m \frac{a_j y_j}{s} (\langle 0|^{\otimes a} U_j |0\rangle^{\otimes a})
    $$

**处理误差**: 实际上只需要做这里的检验就能够完成，非常简单（上面的是启发式的推导，告诉你为什么要构造那个特定的幺正变换）
我们知道 $U_j$ 是 $A_j$ 的一个 $(a_j, a, \varepsilon)$-块编码，这意味着：
$$
\| A_j - a_j (\langle 0|^{\otimes a} U_j |0\rangle^{\otimes a}) \| \le a_j \varepsilon
$$
因此， $\langle 0|^{\otimes a} U_j |0\rangle^{\otimes a}$ 是 $A_j/a_j$ 的一个很好的近似。
我们想计算我们构造的算符 $A' = s \cdot A_{\text{eff}}$ 与目标算符 $A = \sum y_j A_j$ 之间的误差。
$$
A' = s \cdot A_{\text{eff}} = \sum_{j=1}^m a_j y_j (\langle 0|^{\otimes a} U_j |0\rangle^{\otimes a})
$$
误差范数为：
$$
\| A - A' \| = \left\| \sum_{j=1}^m y_j A_j - \sum_{j=1}^m a_j y_j (\langle 0|^{\otimes a} U_j |0\rangle^{\otimes a}) \right\|
$$
$$
= \left\| \sum_{j=1}^m y_j \left( A_j - a_j (\langle 0|^{\otimes a} U_j |0\rangle^{\otimes a}) \right) \right\|
$$
利用三角不等式：
$$
\le \sum_{j=1}^m y_j \left\| A_j - a_j (\langle 0|^{\otimes a} U_j |0\rangle^{\otimes a}) \right\| \le \sum_{j=1}^m y_j (a_j \varepsilon)
$$
这证明了最终的块编码是一个 $(\sum y_j a_j, a+b, (\sum y_j a_j)\varepsilon)$-块编码，与引理陈述相符。

---

#### 文献与上下文

LCU 技术是现代量子算法的支柱之一，其发展脉络清晰：
*   **思想起源**: 该思想可以追溯到早期的哈密顿模拟工作，其中哈密顿量被分解为酉算符（如泡利算符）的线性组合。
*   **早期形式化**: **Andrew M. Childs 和 Nathan Wiebe** 在 2012 年关于稀疏哈密顿模拟的工作中明确使用了 LCU 技术。
    > 引用: A. M. Childs and N. Wiebe, *Quantum simulation of sparse Hamiltonians*, Quantum Information & Computation 12, 901-924 (2012).
*   **在泰勒级数模拟中的应用**: **Berry, Childs, Kothari, Somma** 等人在 2015 年的工作中，利用 LCU 来实现哈密顿演化 $e^{-iHt}$ 的泰勒级数展开 $\sum_k \frac{(-iHt)^k}{k!}$ 的每一项，极大地推动了该技术的重要性。
*   **块编码与 QSVT 框架下的成熟形式**: **Low 和 Chuang** 在关于 Qubitization 的工作中，以及 **Gilyén, Su, Low, Wiebe** 在关于 QSVT 的论文中，将 LCU 推广并形式化为**块编码的线性组合**，即 Lemma 4 的形式。这使其成为一个高度模块化和可组合的工具。
    > 引用: A. Gilyén, Y. Su, G. H. Low, and N. Wiebe, *Quantum singular value transformation and beyond...*, STOC 2019 (arXiv:1806.01838). (本引理对应其 Lemma 52)

#### 引理的意义

**Lemma 4 是量子算法的“乐高积木”**。它提供了一种将简单、已知的构建块（$A_j$ 的块编码）组合成更复杂、更有用结构（$A = \sum y_j A_j$ 的块编码）的通用方法。

它的核心意义在于**可组合性 (Composability)** 和**模块化 (Modularity)**：
1.  **构建复杂的哈密顿量**: 任何哈密顿量都可以分解为泡利算符的线性组合 $H = \sum \alpha_k P_k$。由于泡利算符 $P_k$ 有简单的块编码（通常 $\alpha=1, m=0$），利用 Lemma 4 可以直接为任意 $H$ 构建块编码。
2.  **实现算法的高阶版本**: 许多算法，如哈密顿模拟、矩阵求逆等，依赖于对算符 $A$ 的多项式或函数逼近。例如，要实现 $e^{-iAt}$，可以取其泰勒级数。Lemma 4 使得构造级数中每一项 $c_k (A/s)^k$ 的块编码成为可能。
3.  **算法设计的标准化接口**: 它允许算法设计者专注于两个独立的问题：(1) 如何为基础算符找到高效的块编码；(2) 如何高效地制备编码了线性组合系数的 `PREPARE` 态。

总之，Lemma 4 是从基础算符构建复杂量子算法的关键桥梁，是量子信号处理（QSP/QSVT）等顶级量子算法能够发挥其强大威力的基础。

上面讨论了“相干叠加”地执行$A_i$，下面考虑如何经典叠加地执行一组$A_i$，即实现一个量子算符。
### Lemma 5 的陈述

**Lemma 5**. 令 $\mathcal{M}$ 是一个由 $m$ 个克劳斯算符 (Kraus operators) $A_1, \dots, A_m \in \mathbb{C}^{2^n \times 2^n}$ 定义的完全正映射 (completely positive map)：
$$
\mathcal{M}(\rho) = \sum_{j=1}^m A_j \rho A_j^\dagger
$$
令 $U_1, \dots, U_m$ 分别是 $A_1, \dots, A_m$ 对应的 $(s_j, n', \varepsilon)$-块编码。即，对于所有的 $j \in [m]$，满足：
$$
\| A_j - s_j (\langle 0|^{\otimes n'} \otimes I) U_j (|0\rangle^{\otimes n'} \otimes I) \| \le s_j \varepsilon
$$
定义一个量子态 $|\mu\rangle$ 如下：
$$
|\mu\rangle := \frac{1}{\sqrt{\sum_{k=1}^m s_k^2}} \sum_{j=1}^m s_j |j\rangle
$$
那么，通过施加一个受控的酉算符 $\left(\sum_{j=1}^m |j\rangle\langle j| \otimes U_j\right)$ 到初始态 $|\mu\rangle|0\rangle^{\otimes n'}|\psi\rangle$ 上，然后再将 $n'$ 个块编码辅助比特投影回 $|0\rangle^{\otimes n'}$，我们可以实现一个操作。这个操作的输出态与理想的“输出叠加态” $\frac{1}{\sqrt{\sum_{k=1}^m s_k^2}} \sum_{j=1}^m |j\rangle \otimes (A_j |\psi\rangle)$ 非常接近，其误差有界。

*具体来说，如论文中的公式(21)所示，这个过程产生的量子态与理想态 $\frac{1}{\mathcal{N}} \sum A_j|\psi\rangle$ 的误差有上界，其中 $\mathcal{N}$ 是归一化因子。*

---

#### 直观讲解与核心思想

**如果说 Lemma 4 (LCU) 是一个“量子算符合成器”，那么 Lemma 5 就是一个“量子演化通道模拟器”。**

一个完全正映射（量子通道）描述了量子系统（例如，与环境有相互作用）可能经历的各种演化的统计集合。对于一个纯态输入 $|\psi\rangle$，输出是一个密度矩阵 $\rho_{\text{out}} = \sum_j A_j |\psi\rangle\langle\psi| A_j^\dagger$。这可以理解为：系统有一定概率演化为由 $A_j$ 描述的末态 $A_j|\psi\rangle$。

**核心思想**：与其在经典计算机上按照概率随机选择一个 $A_j$ 来施加，量子计算机可以利用叠加原理，**同时、相干地探索所有可能的演化路径**。

这个引理的构造过程如下：

1.  **准备 (PREPARE)**: 我们使用一个专门的状态 $|\mu\rangle$ 来创建一个“演化路径”的叠加态。每个分支 $|j\rangle$ 代表系统选择第 $j$ 条演化路径（即由 $A_j$ 描述的演化）。每个分支的振幅 $s_j / \mathcal{N}$ 精确地编码了这条路径的“权重”，这个权重直接来源于 $A_j$ 的块编码归一化因子 $s_j$。

2.  **选择并演化 (SELECT & EVOLVE)**: 我们施加一个受控的酉操作。该操作检查“路径”寄存器的状态：如果寄存器处于 $|j\rangle$，它就在系统和块编码辅助比特上施加对应的块编码酉算符 $U_j$。

3.  **实现算符 (POST-SELECT on Ancillas)**: 在施加 $U_j$ 之后，我们通过将 $n'$ 个块编码辅助比特投影（或后选择）到 $|0\rangle$ 状态，来近似地在系统上实现算符 $A_j/s_j$ 的效果。

**最终结果**：这个过程的最终输出不是一个单一的系统状态，而是一个**纠缠态**。这个纠缠态将“路径”寄存器和系统寄存器关联起来，其形式为：
$$
|\Psi_{\text{final}}\rangle \approx \frac{1}{\mathcal{N}} \sum_{j=1}^m |j\rangle \otimes (A_j |\psi\rangle)
$$
这个态非常强大，因为它**相干地编码了所有可能的演化结果**。如果我们忽略（或追踪掉）“路径”寄存器，得到的系统密度矩阵恰好就是我们想要的 $\mathcal{M}(|\psi\rangle\langle\psi|)$。

**与 Stinespring 扩张定理的关系**: 这个引理提供了一个**构造性的 Stinespring 扩张**。该定理指出，任何完全正映射都可以被看作是在一个更大的希尔伯特空间上进行幺正演化，然后将辅助系统（环境）追踪掉的结果。Lemma 5 中的电路正是这个更大幺正演化的一部分（具体来说是一个等距映射），而“路径”寄存器 $|j\rangle$ 就扮演了辅助系统（环境）的角色。

---

#### 证明与电路构造

我们将逐步推导这个过程，并验证其正确性。

**初始态**: 整个系统的初始态由三部分组成：
$|\Psi_{\text{init}}\rangle = |\mu\rangle \otimes |0\rangle^{\otimes n'} \otimes |\psi\rangle = \left( \frac{1}{\sqrt{\sum s_k^2}} \sum_{j=1}^m s_j |j\rangle \right) \otimes |0\rangle^{\otimes n'} \otimes |\psi\rangle$

**施加的算符**: 我们定义一个受控的酉算符 $V$ (即 `SELECT` 算符)：
$$
V := \sum_{j=1}^m |j\rangle\langle j| \otimes U_j
$$

1.  **施加 V**:
    将 $V$ 作用于初始态 $|\Psi_{\text{init}}\rangle$：
    $$
    V |\Psi_{\text{init}}\rangle = \frac{1}{\sqrt{\sum s_k^2}} \sum_{j=1}^m s_j \left( (|j\rangle\langle j| \otimes U_j) (|j\rangle \otimes |0\rangle^{\otimes n'} \otimes |\psi\rangle) \right)
    $$
    $$
    = \frac{1}{\sqrt{\sum s_k^2}} \sum_{j=1}^m s_j |j\rangle \otimes \left( U_j (|0\rangle^{\otimes n'} \otimes |\psi\rangle) \right)
    $$
    得到一个纠缠态，其中第 $j$ 个分支的系统部分被施加了 $U_j$。

2.  **投影块编码辅助比特**:
    现在，我们施加一个投影算符 $P_0 = I \otimes (\langle 0|^{\otimes n'}) \otimes I$ 来提取块编码成功的部分。我们将得到一个作用在“路径”和系统寄存器上的等效操作：
    $$
    (P_0 \cdot V) |\Psi_{\text{init}}\rangle = \frac{1}{\sqrt{\sum s_k^2}} \sum_{j=1}^m s_j |j\rangle \otimes \left( (\langle 0|^{\otimes n'} U_j |0\rangle^{\otimes n'}) |\psi\rangle \right)
    $$
    这个表达式描述了实际电路产生的（近似）最终状态。

3.  **与理想状态比较并计算误差**:
    理想的最终状态是：
    $$
    |\Psi_{\text{ideal}}\rangle = \frac{1}{\sqrt{\sum s_k^2}} \sum_{j=1}^m |j\rangle \otimes (A_j |\psi\rangle)
    $$
    我们需要计算这两个状态之间的差的范数。
    $$
    \| (P_0 \cdot V) |\Psi_{\text{init}}\rangle - |\Psi_{\text{ideal}}\rangle \|
    $$
    $$
    = \left\| \frac{1}{\sqrt{\sum s_k^2}} \sum_{j=1}^m s_j |j\rangle \otimes \left( (\langle 0| U_j |0\rangle) |\psi\rangle \right) - \frac{1}{\sqrt{\sum s_k^2}} \sum_{j=1}^m |j\rangle \otimes (A_j |\psi\rangle) \right\|
    $$
    由于 $|j\rangle$ 是正交基，我们可以将范数内的求和提出来：
    $$
    = \frac{1}{\sqrt{\sum s_k^2}} \left\| \sum_{j=1}^m |j\rangle \otimes \left( s_j (\langle 0| U_j |0\rangle) - A_j \right) |\psi\rangle \right\|
    $$
    因为不同 $j$ 的分支是正交的，一个向量 $\sum_j |j\rangle \otimes |v_j\rangle$ 的范数的平方是 $\sum_j \| |v_j\rangle \|^2$。因此，
    $$
    \le \frac{1}{\sqrt{\sum s_k^2}} \sqrt{ \sum_{j=1}^m \| (s_j \langle 0| U_j |0\rangle - A_j) |\psi\rangle \|^2 }
    $$
    利用算符范数的定义 $\|Mv\| \le \|M\|\|v\|$ 和 $|\psi\rangle$ 的归一性：
    $$
    \le \frac{1}{\sqrt{\sum s_k^2}} \sqrt{ \sum_{j=1}^m \| s_j \langle 0| U_j |0\rangle - A_j \|^2 }
    $$
    根据块编码的误差定义 $\| s_j \langle 0| U_j |0\rangle - A_j \| \le s_j\varepsilon$：
    $$
    \le \frac{1}{\sqrt{\sum s_k^2}} \sqrt{ \sum_{j=1}^m (s_j\varepsilon)^2 } = \frac{\varepsilon \sqrt{\sum s_j^2}}{\sqrt{\sum s_k^2}} = \varepsilon
    $$
    这个简化的推导表明误差与 $\varepsilon$ 成正比，与论文中的结果精神一致（具体系数可能因范数定义等细节略有差异）。

---

#### 文献与上下文

*   **理论基础**: 这个引理是**量子通道模拟**的直接算法实现。它在概念上与 **Stinespring 扩张** 和 **Sz.-Nagy 扩张定理** 紧密相关，这些是算子理论中将非收缩/非酉操作嵌入到更大空间中的酉操作的基础。
*   **算法前身**: **Cleve 和 Wang (2017)** 在他们的论文 "Efficient quantum algorithms for simulating Lindblad evolution" 中，为模拟 Lindblad 方程的无穷小步演化，已经使用了这种构造。Lindblad 方程的无穷小演化 $e^{\mathcal{L}\delta t} \approx I + \mathcal{L}\delta t$ 可以写成克劳斯形式，其克劳斯算符为 $A_0 \approx I - iH_{\text{eff}}\delta t - \frac{1}{2}\sum_k L_k^\dagger L_k \delta t$ 和 $A_k \approx \sqrt{\delta t} L_k$。他们的工作就是为这些具体的 $A_k$ 实现这种受控演化。
*   **本文的贡献**: 这篇论文中的 **Lemma 5** 的主要贡献是将这一技术**推广并适配到通用的块编码框架**。这极大地增强了它的模块化和适用性。现在，我们不再需要为每一个 $A_j$ 单独设计电路，只要我们能为它们找到块编码（例如，如果 $A_j$ 是稀疏的，就用 Lemma 3；如果 $A_j$ 是线性组合，就用 Lemma 4），就可以像搭积木一样，直接用 Lemma 5 来构建整个量子通道的模拟。

#### 引理的意义

**Lemma 5 是连接开放量子系统理论与量子算法实践的核心桥梁**。

1.  **模拟开放系统动力学的基本步骤**: 它是本文提出的非马尔可夫系统模拟算法的核心。算法将总演化时间 $t$ 分割成许多小步 $\delta t$。每一步的演化 $e^{\mathcal{L}\delta t}$ 都被近似为一个 CP 映射，然后使用 Lemma 5 来实现这一小步演化。通过重复这个过程，就可以模拟整个动力学。

2.  **通用性与模块化**: 由于它接受**块编码**作为输入，任何可以被块编码的克劳斯算符集合所描述的量子通道，都可以用这种标准化的方式进行模拟。这使得算法设计变得非常清晰和模块化。

3.  **超越密度矩阵**: 这个引理产生的是一个**纯化的纠缠态**，而不是密度矩阵。在许多量子算法中，直接操作纯态比操作密度矩阵要高效得多。这个输出态可以作为后续量子算法（如幅度放大）的输入，这是其相比于经典模拟的一个巨大优势。