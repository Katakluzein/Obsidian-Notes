---
{"dg-publish":true,"permalink":"/1 Stories of Bizzo's Life/5 量子科学和量子技术/27 量子算法/"}
---



> [!quote] 
>  Quantum computation is... a distinctively new way of harnessing nature... It will be the first technology that allows useful tasks to be performed in collaboration between parallel universes. 
>  —— David Deutsch
{ #x2cvao}


> [!quote] 

> [!abstract] Contents
> - 算法

在量子计算研究初期，对于量子计算的质疑主要集中在量子系统的退相干性和噪声对大规模量子系统的破坏性影响。 量子纠错解错码、量子容错计算等方面的研究逐步打消了这方面的担忧。量子阈值定理给出了确定的噪声阈值——只要计算过程中每个部件的噪声控制在阈值之下，任意大规模的量子计算都能实现。 这在理论上铺平了量子计算发展的道路, 量子计算的实现看起只是一个工程技术问题。\par 

课程讲义，参见：第一章 量子计算简介.nb，第四章 量子线路.nb。

## 基本公式
基本公式在量子力学相关章节。
## 量子算法
在计算机理论方面，量子计算能否计算经典计算机无法计算的问题，或者能否在某些问题上超越经典计算机的计算效率，都是量子计算研究的重中之重。主要的量子算法包括：
> [!abstract] Contents
> - 基于量子Fourier变换的算法，Deutsch-Jozsa算法、Shor算法、离散对数算法。
> - 量子搜索算法。
> - 量子模拟。

### Deutsch算法
Deutsch能够仅仅通过一步计算就得到关于函数$f$的整体性质$f(0)\oplus f(1)$，体现了量子算法的并行性\footnote{参见：Deutsch算法.nb和Nielsen 第一章.nb}。这个算法启示我们，如果经典算法为了完成指定的任务需要获取额外的信息量，那么量子算法就有可能以更少的计算完成相同的任务。

 Deutsch算法，设$f(x)=x$
![[deutschAlgo.pdf]]
 
### Shor算法
- [[整理前的Shor算法\|整理前的Shor算法]] 
好的，已将您提供的关于Shor算法的内容整理为Markdown格式。

### Shor算法

Shor算法用于高效地解决大整数质因数分解问题。大数分解的困难性是当前广泛使用的RSA (Rivest-Shamir-Adleman) 公钥密码系统的安全基础。在经典计算中，已知用于分解大数（例如超过$10^{100}$）的最高效算法是通用数域筛 (General Number Field Sieve, GNFS)，其时间复杂度为：
$$
\exp \left(\left(\sqrt[3]{\frac{64}{9}}+o(1)\right)(\ln n)^{\frac{1}{3}}(\ln \ln n)^{\frac{2}{3}}\right)
$$
Shor算法则可以在多项式时间内完成这个任务，其主要步骤如下：

1.  **输入**：一个奇数 $N$，且已知 $N$ 至少有两个质因子。
2.  **随机选择**：任选一个小于 $N$ 的整数 $y$，并计算 $\mathrm{gcd}(y, N)$。如果结果不为1，则已找到一个因子，算法结束。如果为1，则 $y$ 与 $N$ 互质，继续下一步。
3.  **量子求阶**：**使用量子算法找到函数 $F_{N}(a)=y^{a} \pmod N$ 的周期 $r$**。这等价于求 $y$ 模 $N$ 的阶，即找到最小的正整数 $r$ 使得 $y^{r} \equiv 1 \pmod N$。
4.  **检查周期**：如果 $r$ 是奇数，则算法失败，返回步骤 (2) 重新选择 $y$。
5.  **计算因子**：如果 $r$ 是偶数，计算 $n_{1}=\operatorname{gcd}\left(y^{r / 2}-1, N\right)$。如果 $n_1=1$ 或 $n_1=N$，则算法失败，返回步骤 (2)。否则，$n_1$ 就是 $N$ 的一个非平凡因子。
6.  **输出结果**：输出因子 $n_{1}$ 和 $n_{2} = N/n_1$。

**关于经典后处理（步骤4和5）的说明：**
如果求出的周期 $r$ 是偶数，则我们有 $y^{r} \equiv 1 \pmod N$，这意味着 $N$ 整除 $(y^r-1)$。我们可以将其分解为 $N | (y^{r/2}-1)(y^{r/2}+1)$。这表明 $N$ 与 $(y^{r/2}-1)$ 和 $(y^{r/2}+1)$ 拥有共同的因子。通过计算 $\operatorname{gcd}\left(y^{r / 2}-1, N\right)$ 和 $\operatorname{gcd}\left(y^{r / 2}+1, N\right)$，我们有很高的概率可以找到 $N$ 的一个非平凡因子。只有当 $y^{r/2} \equiv -1 \pmod N$ 时，$\operatorname{gcd}\left(y^{r / 2}-1, N\right)=1$，或者当 $N$ 本身整除 $y^{r/2}-1$ 时，$\operatorname{gcd}\left(y^{r / 2}-1, N\right)=N$，这两种情况下算法会失败，需要重新选择 $y$。可以证明，随机选择的 $y$ 至少有 $1/2$ 的概率可以成功分解 $N$。

---

### 核心量子模块：求阶算法

Shor算法的核心是其量子求阶（Order-Finding）子程序。这个子程序依赖于量子傅里叶变换（QFT）。

#### 量子傅里叶变换 (QFT)
量子傅里叶变换是经典离散傅里叶变换的量子模拟。对于一个 $N=2^n$ 维的希尔伯特空间，它将计算基矢 $|j\rangle$ 映射为：
$$
\mathrm{QFT}|j\rangle = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} \mathrm{e}^{2 \pi \mathrm{i} j k / N}|k\rangle
$$
利用二进制表示 $j = j_1 j_2 \dots j_n$，上式可以分解为更易于量子线路实现的张量积形式：
$$
\mathrm{QFT}|j\rangle = \frac{1}{2^{n / 2}} \bigotimes_{l=1}^{n}\left(|0\rangle+\mathrm{e}^{2 \pi \mathrm{i} j / 2^{l}}|1\rangle\right)
$$
作为算符，QFT可以写成：
$$
\mathrm{QFT}:=\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1} \sum_{k=0}^{N-1} \exp \left(2 \pi \mathrm{i} \frac{k j}{N}\right)|k\rangle\langle j|
$$
设 $\omega_{n}:=\exp \left(\frac{2 \pi \mathrm{i}}{2^{n}}\right)$，QFT的矩阵形式为一个 $2^n \times 2^n$ 的矩阵：
$$
\mathrm{QFT}=\frac{1}{\sqrt{2^{n}}}
\begin{pmatrix}
1 & 1 & \cdots & 1 \\
1 & \omega_{n} & \cdots & \omega_{n}^{2^{n}-1} \\
\vdots & \vdots & \ddots & \vdots \\
1 & \omega_{n}^{2^{n}-1} & \cdots & \omega_{n}^{\left(2^{n}-1\right)^{2}}
\end{pmatrix}
$$
这是一个特殊的范德蒙德矩阵。

#### 量子求阶算法步骤
量子求阶算法的步骤如下：

1.  **初始化**：准备两个量子寄存器。第一个寄存器（输入寄存器）包含 $L$ 个量子比特，第二个寄存器（输出寄存器）也包含足够多的量子比特。选择一个整数 $q=2^L$ 使得 $N^2 \le q < 2N^2$。将第一个寄存器初始化为均匀叠加态，第二个寄存器初始化为 $|0\rangle$：
    $$
    \frac{1}{\sqrt{q}} \sum_{a=0}^{q-1}|a\rangle \otimes |0\rangle
    $$

2.  **模指数运算**：构造一个幺正算符 $U$ 来实现模指数运算 $U|a\rangle|z\rangle = |a\rangle|z \cdot y^a \pmod N\rangle$。将其作用于初态上（这里 $z=1$，或更一般地，从 $|0\rangle$ 开始计算）：
    $$
    \frac{1}{\sqrt{q}} \sum_{a=0}^{q-1}|a\rangle \otimes |y^{a} \pmod N\rangle
    $$

3.  **量子傅里叶逆变换**：对第一个寄存器进行量子傅里叶逆变换 ($\mathrm{QFT}^{\dagger}$)。
    $$
    \begin{aligned}
    & \quad \frac{1}{q} \sum_{k=0}^{q-1}\sum_{a=0}^{q-1} e^{-2 \pi i k a / q}|k\rangle \otimes |y^{a} \pmod N\rangle \\
    &= \frac{1}{q} \sum_{k=0}^{q-1} \sum_{l=0}^{r-1} \left( \sum_{m=0}^{\lfloor (q-1-l)/r \rfloor} e^{-2 \pi i k(m r+l) / q} \right) |k\rangle \otimes |y^{l} \pmod N\rangle
    \end{aligned}
    $$
    *(注：您原文中是正变换，但通常求阶算法使用逆变换来提取周期性信息。)*

4.  **测量**：测量第一个寄存器。由于函数 $f(a)=y^a \pmod N$ 的周期为 $r$，测量结果 $k$ 会以很高的概率集中在接近 $q/r$ 的整数倍的值上，即 $k \approx \frac{c \cdot q}{r}$，其中 $c$ 是某个整数。

5.  **经典后处理**：对测量得到的结果 $k$ 进行处理。通过计算 $k/q$，我们可以得到 $c/r$ 的一个很好的近似值。利用**连分数算法 (Continued Fraction Algorithm)**，可以从这个近似值中高效地恢复出周期 $r$。

6.  **(待补充) 如何从高概率的测量结果中提取出 $r$。**
    详细来说，测量后得到 $k$ 的概率振幅是关于 $k r / q$ 的函数。当 $kr/q$ 是整数时，概率达到峰值。因此，我们得到的测量结果 $k$ 很可能满足 $k/q \approx c/r$。连分数算法是一种从有理数的近似值中找出其最简分数表示的经典算法。将 $k/q$ 作为输入，该算法能够输出一系列分数，其中一个很可能就是 $c/r$ 的约分形式。通过尝试不同的 $c$ 的可能值（通常是小整数），我们可以找到一个候选周期 $r'$，然后通过经典计算验证 $y^{r'} \equiv 1 \pmod N$ 是否成立。
### 隐藏子群问题HSP

> [!definition] 子群的隐藏
> - $G$是一个群，$H$是其子群，$X$是一个集合，函数$f:G\rightarrow X$，若任取$g_1,g_2\in G$，有
$$
f(g_1)=f(g_2)\Leftrightarrow g_1H=g_2H
$$
>   则称函数$f$**隐藏**了子群$H$。

> [!note]
> - 用群作用的观点来看，一个陪集就是$H$作用在$G$上产生的一条轨道。对于被$f$隐藏的子群$H$，两个群元的函数值相等等价于其关于$H$的陪集相同，也就是说，两个群元的函数值相等等价于他们\myemph{产生相同的轨道}。

> [!example]
> - $f$隐藏了$H$的例子：
>
$$
\begin{array}{l}G=\mathbb{Z}_{6}=\{0,1,2,3,4,5\} \\ H=\langle 2\rangle =\mathbb{Z}_{3}=\{0,2,4\} \\ {[0]=0+H=\{0,2,4\}=[2]=[4]} \\ {[1]=1+H=\{1,3,5\}=[3]=[5]} \\ f(0)=f(2)=f(4) \neq f(1)=f(3)=f(5)\end{array}
$$
考虑循环群的子群[[lomont2004HiddenSubgroupProblem\|lomont2004HiddenSubgroupProblem]]，给定正整数$N$，$G=\left\langle\mathbb{Z}_{N},+\right\rangle$是模$N$加法群，$f:G\rightarrow X$隐藏了子群$H=\langle d\rangle=\{|0\rangle,|d\rangle,|2 d\rangle, \ldots,|(M-1) d\rangle\}$，$|G|=N,|H|=M,d=N/M$。我们可以执行黑箱幺正变换
$$
U_f:|x\rangle|y\rangle \rightarrow|x\rangle|f(x) \oplus y\rangle
$$
具体算法如下
\begin{itemize}
	\item 将两个寄存器初始化到
$$
|0\rangle|0\rangle
$$
\item 第一个寄存器做成均匀叠加，得到
$$
\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1}|j\rangle|0\rangle
$$
\item 作用一次$U_f$，
$$
\frac{1}{\sqrt{N}} \sum_{j=0}^{N-1}|j\rangle|f(j)\rangle
$$
\item 测量第二寄存器得到$|f(j_0)\rangle$，测得结果后舍弃第二寄存器，此时第一寄存器会仅剩下$j_0+H$的中的态的均匀叠加，
$$
|j_0+H\rangle\equiv \frac{1}{\sqrt{M}} \sum_{h \in H}\left|j_{0}+h\right\rangle=\frac{1}{\sqrt{M}} \sum_{s=0}^{M-1}\left|j_{0}+s d\right\rangle
$$
\item 对第一寄存器做傅里叶变换，只有$M=|H|$的整数倍存活下来，
$$
\mathrm{QFT}\frac{1}{\sqrt{M}} \sum_{s=0}^{M-1}\left|j_{0}+s d\right\rangle=\frac{1}{\sqrt{M}} \sum_{s} \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} e^{\frac{2 \pi i\left(j_{0}+s d\right) k}{N}}|k\rangle=\frac{1}{\sqrt{d}} \sum_{t=0}^{d-1} e^{\frac{2 \pi i j_{0} t M}{N}}|t M\rangle
$$
\item 测量第一寄存器，得到$M$的整数倍的态的均匀分布。重复上述步骤若干次，得到$t_1M,\ldots, t_kM,~1\leqslant t_i<d$，用辗转相除法(欧几里得算法)确定这些测量结果的最大公约数$M$。
	成功概率（[[lomont2004HiddenSubgroupProblem\|lomont2004HiddenSubgroupProblem]] Apdx.E）
$$
\operatorname{Pr}\left(\operatorname{gcd}\left(t_{1}, t_{2}, \ldots, t_{k}\right)=1\right) \geqslant 1-\left(\frac{1}{2}\right)^{k / 2}
$$
\end{itemize}


### 量子搜索算法
Householder变换
$$
\begin{aligned} H:|x\rangle  & \mapsto|x\rangle-2\langle\psi | x\rangle|\psi\rangle \\ & =(\mathbb{I}-2|\psi\rangle\langle\psi|)|x\rangle\end{aligned}
$$
## 魔法态 Magic State
魔法态的刻画[[gu2023little\|gu2023little]]：
> [!abstract] Contents
> - 非 Clifford 性质：魔法态不是 Clifford 群的元素，这意味着它们不能仅通过 Clifford 门（如单量子比特泡利门和 CNOT 门）来制备。这使得它们在量子计算中具有非平凡的特性，因为它们可以用于实现非 Clifford 量子门，如 T 门。
> - 高魔法值：魔法态的魔法值（magic value）通常很高，这意味着它们在量子系统中的非经典性程度较高。魔法值是衡量量子态非 Clifford 资源的量度，与量子态的非稳定子集（nonstabilizer subspace）的大小有关。
> - 蒸馏和合成：在量子错误校正中，魔法态可以通过特定的协议（如魔法态蒸馏）从多个副本中提取出来，以提高其质量。此外，魔法态也可以通过量子门操作从其他量子态合成。
> - 量子优势：魔法态的存在与量子计算中的量子优势直接相关。它们是实现某些量子算法（如量子搜索算法）的关键资源，这些算法在量子计算机上比在经典计算机上运行得更快。

## 变分量子求解器 Variational Quantum Eigensolver

# 松散的内容
- [[forrelation\|forrelation]]  [[0 fleeting/未解问题与新项目/新项目#^76sepr\|新项目#^76sepr]]
- [Quantum Algorithms: A Call To Action | Quantum Frontiers ~ 量子算法：行动电话|量子前沿](https://quantumfrontiers.com/2025/04/20/quantum-algorithms-a-call-to-action/)
	- 还提到两种不是那么像量子算法的能够体现量子优越性的应用：[[learning with quantum memory\|learning with quantum memory]], [[quantum streaming\|quantum streaming]] 

- 
### 实现量子加速的算法

#### **像Shor算法这样成功的其他量子算法**

是的，除了Shor算法，还有其他几个重要的量子算法，它们同样利用了问题的特殊结构，在 `NP ∩ co-NP` 或其他具有相似特性的复杂性类中取得了指数级或超多项式的加速。

这些成功的算法，几乎都围绕着一个核心的、更广义的问题框架：**隐子群问题 (Hidden Subgroup Problem, HSP)**。

**隐子群问题 (HSP)** 是一个统一的框架，Shor算法是它的一个特例。它的目标是：给定一个群 `G` 和一个函数 `f`，这个函数 `f` 在一个未知的子群 `H` 的陪集上是常数。你的任务是找出这个“隐藏”的子群 `H`。

Shor算法的成功之处在于，它利用**量子傅里叶变换 (QFT)** 高效地解决了**阿贝尔群（Abelian Groups，即群内元素满足交换律）**上的HSP。

以下是其他几个成功的例子：

1.  **离散对数问题 (Discrete Logarithm Problem)**
    *   **问题**：给定素数 `p` 和生成元 `g`，以及一个数 `y`，找到 `x` 使得 `g^x ≡ y (mod p)`。这是许多公钥密码学（如Diffie-Hellman密钥交换）的基础。
    *   **量子算法**：Shor的算法框架同样适用，通过QFT解决。
    *   **复杂性类**：与大数分解类似，也在 `NP ∩ co-NP` 的“边缘”，被认为不是NP完全问题。
    *   **“秘诀”**：同样是利用了模算术下隐藏的**周期性结构**。

2.  **佩尔方程 (Pell's Equation) 与主理想问题 (Principal Ideal Problem)**
    *   **问题**：这些是来自代数数论的更复杂的问题。例如，佩尔方程是寻找方程 `x² - ny² = 1` 的整数解。
    *   **量子算法**：由Hallgren在2007年提出。它推广了Shor算法的思想，能够解决更复杂的代数结构（数域的单位群）中的HSP，这些结构不再是简单的循环群。
    *   **意义**：这表明QFT的威力**不仅限于简单的周期性**，还可以用来揭示更广义的代数结构。

3.  **量子模拟 (Quantum Simulation)**
    *   **问题**：计算和预测分子、材料或其他量子力学系统的行为。经典计算机模拟这些系统时，所需资源会随系统规模指数级增长。
    *   **量子算法**：这是量子计算最原生的应用之一。理查德·费曼最初提出量子计算机的构想，就是为了模拟量子系统。量子计算机本身就是一个可控的量子系统，因此它能**自然地、高效地**模拟其他量子系统的演化。
    *   **复杂性类**：这个问题属于 **BQP** (有界错误量子多项式时间)，但被认为不属于 `P`。
    *   **“秘诀”**：利用了“**以量子制量子**”的原理，问题的结构（量子力学）与计算机的结构完美匹配。

4.  **求解线性方程组 (HHL Algorithm)**
    *   **问题**：求解线性方程组 `Ax = b`。
    *   **量子算法**：Harrow, Hassidim, 和 Lloyd 提出的HHL算法能在特定条件下提供指数级加速。
    *   **重要限制**：这个算法有非常严格的适用条件（例如，矩阵A是稀疏的，我们需要准备特定的量子态，且最终得到的是关于解向量x的某种期望值，而不是x本身）。
    *   **“秘诀”**：利用了**量子相位估计**来高效地计算矩阵的本征值，从而实现矩阵求逆。

#### **结论：成功的“秘诀”是什么？**

这些成功的量子算法有一个共同点，也是它们与NP完全问题的根本区别：

**它们所解决的问题都具有深刻的、可被量子计算机利用的“隐藏结构”。**

*   对于Shor算法及其推广，这个结构是**代数周期性**，量子傅里叶变换是打开这把锁的钥匙。
*   对于量子模拟，这个结构就是**量子力学本身的演化规律**。
*   对于HHL，这个结构是**线性代数的内在性质**。

而NP完全问题（如旅行商、3-SAT）的“困难”之处，恰恰在于它们被认为是**“无结构的”或“混沌的”**。它们的困难源于局部约束的组合爆炸，缺乏那种可以被量子傅里叶变换等工具一举破解的全局性、规律性的结构。

因此，量子计算机并非万能的“神谕”，它更像是一位**“结构发现大师”**。对于那些拥有特殊数学结构的问题，它能展现出惊人的力量；而对于那些看似随机和组合性的难题，它目前能提供的帮助，主要还停留在Grover算法的平方加速上。