---
{"dg-publish":true,"permalink":"/Grand Unification of Quantum Algorithms/","tags":["论文阅读笔记","量子算法","量子模拟"]}
---

好的，这是一份对论文《Grand Unification of Quantum Algorithms》的详细解析。

## 论文信息和标签
-   **标题**: Grand Unification of Quantum Algorithms (量子算法的大统一)
-   **作者**: John M. Martyn, Zane M. Rossi, Andrew K. Tan, and Isaac L. Chuang
-   **年份**: 2021
-   **期刊/会议**: PRX QUANTUM 2, 040203 (2021)
-   **链接或 DOI**: [10.1103/PRXQuantum.2.040203](https://doi.org/10.1103/PRXQuantum.2.040203)
-   **关键词**: Quantum Singular Value Transformation (QSVT), Quantum Signal Processing (QSP), Quantum Algorithms, Grand Unification, Block Encoding, Hamiltonian Simulation, Quantum Search, Phase Estimation

## 内容

### 领域
- Quantum Computation
- Quantum Algorithms
- Theoretical Computer Science
- Theoretical Physics

### 摘要
量子算法为各种问题提供了超越其经典对应物的显著加速。这种优势最有力的论据来自于量子搜索、量子相位估计和哈密顿量模拟算法，这些算法是大量复合量子算法的子程序。最近，许多这类量子算法被一种称为**量子奇异值变换** (**QSVT**) 的新技术联系在一起。QSVT能够对嵌入在一个酉矩阵中的线性算符的奇异值执行多项式变换。在关于QSVT的开创性论文GSLW'19中，涵盖了许多算法，包括振幅放大、量子线性系统问题的方法以及量子模拟。在这里，我们通过这些发展提供了一个教学性的教程，首先阐述了**量子信号处理** (**QSP**) 如何被推广到量子特征值变换，并由此自然地引出QSVT。与GSLW'19并行，我们接着利用QSVT构建了用于搜索、相位估计和哈密顿量模拟的直观量子算法，并展示了用于特征值阈值问题和矩阵求逆的算法。这篇综述阐明了QSVT如何成为一个包含三大主要量子算法的单一框架，从而提出了量子算法的**大统一**。

### 总体思路
这篇教程的核心目标是阐述一个革命性的观点：许多基本且看似无关的量子算法，如Grover搜索、相位估计（Shor算法的核心）和哈密顿量模拟，实际上可以被一个统一的框架——**量子奇异值变换** (**QSVT**)——所描述和构建。作者试图回答的问题是：“这些来源不同、结构各异的量子算法背后是否存在一个共同的数学和物理根源？”

文章的总体思路和故事线如下：

1.  **从根源出发：量子信号处理 (QSP)**
    文章从最简单的单量子比特场景开始，介绍了**QSP**。QSP是一种通过交替应用“信号旋转”和“处理旋转”来对信号（一个旋转角度）实现任意多项式函数变换的技术。这是一个非常强大且基础的工具。

2.  **推广到多比特系统：从QSP到QSVT**
    接着，文章展示了如何将单比特的QSP思想推广到处理高维的多比特系统。这里的关键飞跃是**qubitization**和**块编码** (Block Encoding) 的概念。一个高维的（非酉）矩阵$A$可以被“编码”到一个更大的酉矩阵$U$的一个块(block)中。通过这种方式，矩阵$A$的奇异值（或特征值）就扮演了单比特QSP中信号参数`a`的角色。
    -   首先，作者展示了这种思想如何应用于**振幅放大**，将两个量子态之间的交叠振幅视为信号。
    -   然后，将其正式化为**量子特征值变换** (**QET**)，可以对一个块编码的哈密顿量$H$的特征值进行多项式变换。
    -   最终，推广到最一般的情形——**量子奇异值变换** (**QSVT**)，可以对任意一个块编码矩阵$A$的奇异值进行多项式变换。这是因为奇异值在处理非厄米或长方形矩阵时更具普适性。

3.  **大统一的实现：用QSVT重构三大算法**
    在建立了QSVT这个强大的框架后，文章的核心部分就是展示如何用它来“重新发现”和改进已知的关键量子算法。对于每个算法，作者都指明了需要块编码的“信号”是什么，以及需要用QSVT实现的“多项式函数”是什么。
    -   **量子搜索 (Search)**: 将搜索问题重新表述为振幅放大问题，其目标是将一个小的奇异值（初始态与目标态的交叠）通过一个近似符号函数的多项式变换映射到接近1。
    -   **相位估计 (Phase Estimation)**: 通过迭代地应用QSVT来执行二进制搜索，逐位确定一个酉算符的本征相位。文章还揭示了这种结构在特定极限下如何自然地演变为我们熟知的量子傅里叶变换电路。
    -   **哈密顿量模拟 (Hamiltonian Simulation)**: 模拟演化算符$e^{-iHt}$可以被看作一个函数求值问题。通过QSVT分别实现$\cos(Ht)$和$\sin(Ht)$的多项式近似（利用雅可比-安格展开），然后将它们组合起来，从而实现哈密顿量模拟，并达到了目前最优的复杂度。
    -   **其他应用**: 文章还展示了如何用QSVT解决特征值阈值问题和矩阵求逆（量子线性系统问题），进一步凸显了其通用性。

**结论**：
本文的结论是，QSVT不仅仅是又一个量子算法，而是一个**元算法**或**统一框架**。它提供了一套“旋钮”（即QSP的相位角），通过调节这些旋钮，可以平滑地从一个算法过渡到另一个。这揭示了不同量子算法加速来源的深刻联系，并为设计新的、更高效的量子算法提供了一个系统性的、强大的工具箱。这种统一性表明，量子计算的核心能力在于对奇异值（或特征值）进行精巧的函数变换。
### intro 
算法通过呈现一个需要遵循的过程或一套规则来解决问题，并利用一组提供的基本构建模块。传统计算机科学采用布尔电路组件作为基本模块，由此可以构建出标准的算术运算，即布尔函数。量子计算则采用一套不同的基本模块，通常是在一个或多个两能级系统（量子比特）上进行幺正操作，以实现量子电路。然而，当试图将量子电路的世界与布尔函数的世界统一起来时，一个根本性的挑战随之出现：通常情况下，布尔函数无需可逆，而量子电路显然是幺正变换，因此必须是可逆的。

在量子计算的早期历史中，这一障碍被开创性的工作 [1] 所突破，该工作表明所有布尔函数都可以被转化为可逆形式，且只需很小的空间和时间开销。Toffoli和Fredkin通过展示有限半径球体（台球）的理想牛顿动力学如何通过碰撞来模拟可逆布尔电路，从而著名地阐释了这一思想 [2]。遵循这一概念，任意布尔函数的模拟也可以通过量子电路来完成，方法是首先将所需函数嵌入到一个可逆布尔电路中，然后构建一个实现该可逆变换的量子电路。例如，在Shor的量子因数分解算法 [3] 中，这种嵌入是一个核心部分，用于实现输入数字的模幂运算。

然而，有趣的是，另外两个主要的“原始”量子算法——Grover的量子搜索算法 [4] 和哈密顿量模拟算法 [5,6]——并没有采用可逆布尔函数的嵌入方法。事实上，量子因数分解算法的一个关键部分是使用了量子傅里叶变换，它没有直接的经典类比，因为它完全不像是一个为傅里叶变换而设计的可逆布尔函数的量子嵌入。然而，这三种算法都为具有明确经典对应物的问题提供了解决方案，并实现了相对于可比较的经典“布尔函数”方法的已知加速。那么，量子算法处理并加速解决经典指定问题的能力究竟源于何处呢？

正如本教程所阐述的，统一量子计算和经典计算的一个关键思想，并非首先将经典计算变得可逆。而是观察到，一个**量子系统的子系统的动力学行为可以是非幺正**的，因此**可以直接实现不可逆的非线性函数**。这方面的一个极端例子是投影测量：台球模型可以通过简单地丢弃球来实现不可逆的门，但这将是低效的。更具建设性的是，最近发展的**量子信号处理**（**QSP**）框架 [7,8] 提供了一种系统性的方法，利用$O(d)$次基本幺正量子操作，使一个量子子系统在近乎任意的$d$次多项式函数下进行变换。至关重要的是，该多项式描述的不是整个量子系统的输出，而只是一个非常具体且明确标识的**子系统**的输出。并且，值得注意的是，QSP背后的基本思想起源于早期对两能级量子系统的实际控制，特别是在核磁共振领域 [9-11]。

借助这个框架，我们在本教程中对量子搜索、因数分解和模拟的现代方法进行了一次教学性的综述，重点关注这三种核心量子算法如何能够被统一为最近发展的**量子奇异值变换**（**QSVT**）算法 [12] 的实例。QSVT算法推广了QSP，并能高效地对一个嵌入在更大幺正算符中的线性算符（该算符支配一个特定的子系统）的奇异值进行多项式变换。最近，这种奇异值变换已被推广到应用于嵌入在哈密顿量块中的算符 [13]。

奇异值在这种背景下自然出现，因为嵌入的线性算符的输入和输出空间的大小可能不同。奇异值的多项式变换是通过对嵌入的子空间应用一个特定的SU(2)旋转序列来实现的，其中每个旋转由一个角度$\phi_k \in \mathbb{R}$参数化。QSVT算法是参数化的，因为其多项式变换完全由相位角 $\{\phi_k\}$ 的选择来表征。此外，给定所需的多项式变换，生成它的QSP相位角可以在经典计算机上高效且稳定地计算出来 [7,12,14]。

这种看似简单的参数化赋予了QSVT巨大的灵活性和威力。利用QSVT作为子程序，我们为**搜索问题和相位估计提出了量子算法**，并给出了通过QSVT实现**最优哈密顿量模拟**和**矩阵求逆**的简化论证。我们还提出了一个基于QSVT的特征值阈值问题算法，即希望知道一个（正规）矩阵是否存在一个高于某个阈值的特征值，并利用它来简化QSVT在相位估计中的应用展示。每种算法都简单地实现为QSVT的一个实例，使用一个自然的预言机，并以一种通用的模式进行自适应重复和穿插简单的量子门及测量。

这种共通的模式尤其引人入胜。从表面上看，用于搜索问题、因数分解（即相位估计）和哈密顿量模拟的算法似乎没有相似的结构，它们的量子加速也源于不同的地方，但它们都可以从一个单一的算法原语中推导出来，并通过简单地改变参数在彼此之间进行插值。此外，这三个核心算法构成了目前已知的大多数量子算法的基础。例如，用于线性系统的Harrow-Hassidim-Lloyd (HHL) 算法 [15] 整合了哈密顿量模拟和相位估计来对一个厄米矩阵求逆；类似地，量子计数算法将量子搜索与相位估计相结合，以计算一个非结构化集合中被标记元素的数量 [16]。如本教程所示，通过简单地调整QSVT的参数，人们可以构建出**几乎**所有已知的量子算法==还有哪些是游离在外的？==。正是在这个意义上，QSVT提供了量子算法的**大统一**。

虽然QSVT的这些应用中有一些已在近期的工作中被涵盖 [12,17]，但我们在此的目标是尽可能地以教学方式呈现这些构造，为每一个构造提供详细的步骤和直觉，并包含明确的例子来支持抽象概念。我们还为这里介绍的每一种算法提供了性能界限和资源需求，我们预计这将会有所帮助。我们希望这次的呈现能使QSVT和QSP更容易被理解，从而催化量子算法的未来发展。

在本教程中，我们假设读者熟悉量子计算的基本概念，如幺正动力学和测量，以及搜索、相位估计和哈密顿量模拟的常规量子算法。关于这些主题的全面综述，请参见文献 [18-20]。此外，我们的目标是使不具备QSP和QSVT先验知识的读者也能理解本文，但如果需要关于这些主题的更多信息，文献 [7,12,21,22] 可以作为有用的参考。
 
我们通过首先在第二节中概述QSVT的发展历程来分享这个量子算法大统一的故事，从**量子信号处理**开始，然后展示这项技术如何引出**量子特征值变换**，并最终导向**量子奇异值变换**。此后，我们详细阐述当前已知量子算法的大统一声明，分别在第三节和第四节中介绍基于QSVT的搜索问题和特征值阈值问题的算法。为了进一步兑现统一的承诺，我们在第五节中介绍了一个通过QSVT进行相位估计的算法，并展示了**量子傅里叶变换**是如何从级联的QSVT序列中涌现出来的。接着，我们在第六节中重点阐述QSVT如何能够产生用于**哈密顿量模拟**和**矩阵求逆**的直观算法。最后，在第七节中，我们探讨这些结果的意义，并讨论QSVT效用的未来研究领域。
### II. FROM QSP TO THE QSVT

### A. 量子信号处理 (Quantum signal processing)
QSP推广了复合脉冲序列 [7,8,23] 的结果，并建立在**交替应用**两种单量子比特旋转的思想之上：一个**信号旋转算符** $W$ 和一个**信号处理旋转算符** $S$。这些旋转操作是围绕布洛赫球的不同轴进行的，例如，通常$W$是绕x轴的旋转，而$S$是绕z轴的旋转。此外，信号旋转总是以相同的角度$\theta$进行，而信号处理旋转则根据某个预定序列以一个可变的角度进行。

例如，令信号旋转算符为
$$
W(a) = \begin{bmatrix} a & i\sqrt{1-a^2} \\ i\sqrt{1-a^2} & a \end{bmatrix}
$$
(1)
这是一个绕x轴旋转角度为$\theta = -2\arccos(a)$的操作。并令信号处理旋转算符为
$$
S(\phi) = e^{i\phi Z}
$$
(2)
这是一个绕z轴旋转角度为$-2\phi$的操作。对于一个相位元组$\vec{\phi} = (\phi_0, \phi_1, \dots, \phi_d) \in \mathbb{R}^{d+1}$，并使用这些约定 [24]，QSP操作序列$U_{\vec{\phi}}$定义为
$$
U_{\vec{\phi}} = e^{i\phi_0 Z} \prod_{k=1}^{d} W(a) e^{i\phi_k Z}
$$
(3)

有趣的是QSP如何能够修改输入信号。假设$\vec{\phi} = (0, 0)$，即没有进行任何处理，此时$U_{\vec{\phi}} = W(a)$只是未改变的信号。如果我们画出输入为$|0\rangle$的量子比特在此操作下保持不变的概率，即$p = |\langle 0 | U_{\vec{\phi}} | 0 \rangle|^2$，作为$\theta$的函数，我们会得到一个漂亮的余弦平方曲线（图1中的下方曲线），因为在这种情况下$p = \cos^2(\theta/2)$。现在，如果我们进行一些信号处理，令$\vec{\phi} = (\pi/2, -\eta, 2\eta, 0, -2\eta, \eta)$，其中$\eta = \frac{1}{2}\arccos(-1/4)$，那么对于使用这些相位的新$U_{\vec{\phi}}$，我们发现新的概率$p = |\langle 0 | U_{\vec{\phi}} | 0 \rangle|^2 = 1/8 \cos^2(\theta/2) [3\cos^8(\theta/2) - 15\cos^6(\theta/2) + 35\cos^4(\theta/2) - 45\cos^2(\theta/2) + 30]$（图1中的上方点划线），对于小的$\theta$来说，这个概率约等于$1 - 5/8(\theta/2)^6$。这具有一个很好的特性，即量子比特在很宽的信号角度范围内都保持不翻转，但随后在$\theta \approx 2\pi/3$附近发生急剧的转变。这增加了对特定信号值的敏感性。

因此，像这样的序列被广泛应用于磁共振成像中以增强图像对比度。这个特定的序列在核磁共振（NMR）领域非常有名，被称为“BB1”脉冲序列 [11]。许多这类“复合脉冲”序列是已知的 [9,25,26]，它们有多种变体，并在实验量子计算中用于抑制特定类型的错误和增强对特定种类信号的敏感性，其实现范围从量子点 [27] 和金刚石中的氮-空位中心 [28]，到囚禁离子 [29-31] 和超导量子比特 [32]。

QSP序列能具有如此的信号变换特性是众所周知的，因为通常情况下，矩阵元$P(a) = \langle 0 | U_{\vec{\phi}} | 0 \rangle$会成为一个关于$a$的多项式，其阶数最多为QSP相位序列$\vec{\phi}$的长度。具体来说，例如，对于$\vec{\phi} = (0, 0)$, $P(a) = a$；对于$\vec{\phi} = (0, 0, 0)$, $P(a) = 2a^2 - 1$；对于$\vec{\phi} = (0, 0, 0, 0)$, $P(a) = 4a^3 - 3a$。这些是**第一类[[切比雪夫多项式\|切比雪夫多项式]]**，$T_d(a)$。

然而，公式(3)中QSP序列最显著的特性可能是这个陈述的**反向命题**：事实证明，对于一个给定的多项式$P(a)$（在一些合理的约束条件下），存在一组QSP相位角$\vec{\phi}$使得$P(a) = \langle 0 | U_{\vec{\phi}} | 0 \rangle$。具体来说 [7]：

**定理1（量子信号处理）**:
- QSP序列$U_{\vec{\phi}}$产生一个可以表示为$a$的多项式函数的矩阵：
$$
e^{i\phi_0 Z} \prod_{k=1}^{d} W(a) e^{i\phi_k Z} = \begin{bmatrix} P(a) & iQ(a)\sqrt{1-a^2} \\ iQ^*(a)\sqrt{1-a^2} & P^*(a) \end{bmatrix}
$$
(4)
对于$a \in [-1, 1]$，
- 对于任意满足以下条件的关于$a$的多项式$P, Q$，都存在一个$\vec{\phi}$：
(i) $\text{deg}(P) \le d, \text{deg}(Q) \le d - 1$
(ii) $P$的奇偶性为$d \pmod 2$，$Q$的奇偶性为$(d - 1) \pmod 2$
(iii) $|P|^2 + (1-a^2)|Q|^2 = 1$

这个定理的正向部分很容易通过归纳法证明，从$d=0$的情况开始，此时$P=e^{i\phi_0}$且$Q=0$。该定理的反向部分则更为复杂，可以通过多种方式证明，包括一个涉及洛朗多项式代数的优雅解释 [33,34]。

然而，我们通常感兴趣的不是可以通过QSP构建的幺正矩阵，而是在一个子系统中可实现的对输入的多项式变换$\text{Poly}(a)$。如果像上面那样，我们选择$\text{Poly}(a) = \langle 0 | U_{\vec{\phi}} | 0 \rangle = P(a)$，那么我们受限于那些存在一个满足定理1条件的多项式$Q$的$P$。这对于某些应用可能是一个相当大的限制。例如，对于$a=\pm 1$，$W(\pm 1)$与单位矩阵成比例，整个QSP序列坍缩为一个单一的z旋转，这限制了我们只能得到满足$|\text{Poly}(\pm 1)| = 1$的多项式$\text{Poly}(a)$。这个限制可以通过定义$\text{Poly}(a) = \langle + | U_{\vec{\phi}} | + \rangle = \text{Re}[P(a)] + i\text{Re}[Q(a)]\sqrt{1-a^2}$来克服。在这种情况下，可以证明我们可以**精确地近似任何实数多项式**，只要它满足奇偶性为$d \pmod 2$，阶数$\text{deg}(\text{Poly}) \le d$，并且$|\text{Poly}(a)| \le 1$对所有$a \in [-1, 1]$成立。这可以通过选择一个合适的$P$，使其真实部分近似于期望的函数，同时选择一个真实部分很小的$Q$来实现。

采用这种约定，可实现的多项式集合对于本教程中描述的所有应用都具有足够的表达能力。通常，用于所需多项式的基矢可以被称为**信号基** (signal basis)，除非另有说明，下面我们都将这个基矢取为$\{|+\rangle, |-\rangle\}$。附录A详细阐述了这一点，并讨论了QSP定理1的不同常规表述。

虽然定理1保证了这样一个$\vec{\phi}$的存在，但它没有提供确定它的方法。幸运的是，类Remez交换算法可以**有效地计算出**一个$\vec{\phi}$，它能对任何可行的多项式$P$和$Q$产生良好的近似 [7]。此外，更高效且数值稳定的算法也已被发现 [33-35]，新的优化技术目前也正在开发中 [36]。附录D为一系列用于实现量子算法的多项式给出了$\vec{\phi}$的明确例子，并展示了一个附带于本教程的开源代码包，用于生成QSP相位角系数。
### B. 在振幅放大和搜索中的一个应用 (An application to amplitude amplification and search)
为了从QSP出发引出QSVT，我们引入一个说明性的例子，展示多量子比特问题如何通过识别出类似量子比特的子系统来简化，从而可以应用QSP的思想。本小节中展示的概念本质上是**量子比特化** (**qubitization**) [8] 的思想，它构成了QSVT的一个核心原则。

具体来说，我们讨论**振幅放大**问题；一个类似的构造将在第三节中讨论，届时将使用QSVT的主要定理，但在这里我们从基本原理出发。希望接下来的论证背后的几何直觉，以及第三节中完全发展的构造的便利性，能够相互补充。

定理1的效用在解决以下问题中得到了很好的展示。假设你被给定一个幺正算符$U$（它可能作用于一个高维度的希尔伯特空间，即不仅仅是一个量子比特）及其逆$U^\dagger$，以及两个算符$A_\phi$和$B_\phi$，它们各自旋转一个特定偏好态的相位，即：
$$
A_\phi = e^{i\phi|A_0\rangle\langle A_0|}
$$
(5)
$$
B_\phi = e^{i\phi|B_0\rangle\langle B_0|}
$$
(6)
挑战在于使用$U, U^\dagger, A_\phi, B_\phi$构建一个电路$Q$，使得
$$
|\langle A_0|Q|B_0\rangle| \to 1
$$
(7)
在电路足够大的极限下，并假设原始矩阵元$\langle A_0|U|B_0\rangle$不为零。

这个问题被称为[[振幅放大\|振幅放大]]，值得注意的是，它可以在不知道具体初始值$\langle A_0|U|B_0\rangle$的情况下，通过使用**不经意的定点振幅放大** (oblivious fixed-point amplitude amplification) 量子算法来解决。我们展示，即使在多量子比特的设置下，这样的算法也仅仅源于定理1，只要认识到在这个问题中存在两个同心的布洛赫球（即类似量子比特的空间）。

具体来说，我们可以认识到$U|B_0\rangle$是一个量子态，它有一个沿着$|A_0\rangle$方向的非零分量，以及另一个与$|A_0\rangle$垂直的分量。因此我们定义
$$
|A_\perp\rangle = \frac{1}{\mathcal{N}}(I - |A_0\rangle\langle A_0|)U|B_0\rangle
$$
(8)
其中$\mathcal{N}$是使$|A_\perp\rangle$成为单位向量所需的归一化因子。于是
$$
U|B_0\rangle = a|A_0\rangle + \sqrt{1-a^2}|A_\perp\rangle
$$
(9)
对于$a=\langle A_0|U|B_0\rangle$（我们可以假设$a$是实数，因为可能的相位可以被吸收到$|B_0\rangle$中）。类似地，我们可以定义某个$|B_\perp\rangle$使得
$$
U|B_\perp\rangle = -a|A_\perp\rangle + \sqrt{1-a^2}|A_0\rangle
$$
(10)
这些思想在图2的示意图中有所展示，使用了我们熟悉的布洛赫球。

**图2**: 振幅放大的示意图。其中，我们希望在不知道具体状态的情况下制备出状态$|A_0\rangle$（这里是某个布洛赫球的北极），仅给定$|B_0\rangle$、一个算符$U$（其$\langle A_0|U|B_0\rangle=a$分量非零），以及通过选定角度绕状态$|B_0\rangle$（蓝色）和$|A_0\rangle$（黑色）旋转的能力。如果我们希望通过向$|A_0\rangle$方向产生一个角度为$\theta = 2\cos^{-1}(\sqrt{1-a^2}) = 2\sin^{-1}a$（红色）的简单旋转，可以在这个模型中恢复标准Grover迭代。

因此，在由$\{|A_0\rangle, |A_\perp\rangle\}$张成的二维希尔伯特空间上，$U$的作用是一个$2 \times 2$的幺正矩阵：
$$
U = a(|A_0\rangle\langle B_0| - |A_\perp\rangle\langle B_\perp|) + \sqrt{1-a^2}(|A_\perp\rangle\langle B_0| + |A_0\rangle\langle B_\perp|)
$$
(11)
这可以方便地表示为矩阵形式：
$$
U = \begin{array}{c|cc} & |B_0\rangle & |B_\perp\rangle \\ \hline |A_0\rangle & a & \sqrt{1-a^2} \\ |A_\perp\rangle & \sqrt{1-a^2} & -a \end{array}
$$
(12)
矩阵上的标签指示列作用于$|B_0\rangle, |B_\perp\rangle$（从左到右），行作用于$|A_0\rangle, |A_\perp\rangle$（从上到下），使得$U$将一个B基矢中的态带到一个A基矢中的态。这两个基矢是编码在该问题中的两个布洛赫球（或量子比特基）。此外，$U$是一个反射操作，我们可以在这个类似量子比特的抽象中表示为$R(a) = XR_y(\theta)$，其中$\theta=2\cos^{-1}(\sqrt{1-a^2})=2\sin^{-1}a$。

这个双布洛赫球的图像为以下定理提供了直观的基础：

**定理2 (振幅放大)**：给定幺正算符$U$，其逆$U^\dagger$，以及算符$A_\phi = e^{i\phi|A_0\rangle\langle A_0|}$，$B_\phi = e^{i\phi|B_0\rangle\langle B_0|}$，
$$
\langle A_0 | \left[\prod_{k=1}^{d/2} U B_{\phi_{2k-1}} U^\dagger A_{\phi_{2k}}\right] U |B_0\rangle = \text{Poly}(a)
$$
(13)
其中$\text{Poly}(a)$是关于$a = \langle A_0|U|B_0\rangle$的一个最多为$d$次的多项式，并满足定理1中对$P$的条件。

这为什么能行？首先注意到$U|B_0\rangle$存在于由$|A_0\rangle$和$|A_\perp\rangle$张成的A-量子比特空间中。这个量子比特然后被$A_\phi$绕其“z轴”旋转。接着$U^\dagger$将其绕y轴旋转（同时也做了一个绕Z轴的反射，但为了直观可以忽略）。$U^\dagger$还将状态从A-量子比特空间映射回由$|B_0\rangle$和$|B_\perp\rangle$张成的B-量子比特空间。接下来，$B_\phi$将状态绕B-量子比特空间的z轴旋转。然后最左边的$U$做另一次y轴旋转（和反射），并将状态映射回A-量子比特空间。方括号中的序列将状态在两个量子比特基之间来回映射，将y轴旋转夹在z轴旋转之间。这种旋转的三明治结构正是在做第二节A中描述的**量子信号处理**；我们很清楚这种行为。

这个定理的正式证明始于注意到在上面定义的两个布洛赫球所定义的子空间上，$U=U^\dagger$。此外，注意到$R(a)$，即$U$的$2 \times 2$幺正表示（在我们问题相关的量子比特基中），与公式(1)中的$W(a)$通过以下方式相关：
$$
R(a) = -ie^{i\frac{\pi}{4}Z} W(a) e^{i\frac{\pi}{4}Z}
$$
(14) ==这个式子给出了$U$和$W(a)$之间的关系，进而给出了振幅放大与QSP的关系。==
将此代入公式(13)并认识到$A_\phi$和$B_\phi$仅仅变成z轴旋转，我们得到
$$
\langle A_0 | e^{i\phi'_0 Z} \left( \prod_{k=1}^{d} W(a) e^{i\phi'_k Z} \right) U |B_0\rangle = \text{Poly}(a)
$$
(15)
其中$\{\phi'_k\}$是原始相位$\{\phi_k\}$的线性组合。根据定理1，括号中的项是一个关于$a$求值的相关多项式矩阵，从而完成了定理2的证明。

当相位$\{\phi_k\}$被选择使得构造出的多项式近似于对小值$a$的符号函数时，定理2就具有了执行“不经意的振幅放大”的意义。生成合适多项式的技术细节将在第三节和附录D1中进一步讨论。

Grover著名的量子搜索算法 [4]，其性质与上述类似，可以很容易地从振幅放大的构造中推导出来。在搜索问题中，某个计算基态$|A_0\rangle$是未知的，但给定一个预言机，它能实现
$$
A_\pi = e^{i\pi|A_0\rangle\langle A_0|}
$$
(16)
目标是使用尽可能少的预言机查询来创建一个接近$|A_0\rangle$的量子态。搜索算法通过选择$U=H^{\otimes n}$（在搜索空间所有量子比特上作用哈达玛门）并从$|B_0\rangle=|0\rangle$开始来解决这个问题。注意，由于$|A_0\rangle$是一个计算基态，$\langle A_0|U|B_0\rangle = 2^{-n/2} = 1/\sqrt{N}$，因为$U|B_0\rangle=|\psi_0\rangle$是搜索空间中所有$N$个基态的等幅叠加。这意味着振幅放大算法可以被应用，并且在$a=1/\sqrt{N}$是已知的情况下，我们选择所有的$\phi_k = \pi$。这个选择意味着
$$
UB_\phi U^\dagger = e^{i\pi H^{\otimes n}|0\rangle\langle 0|H^{\otimes n}} = I - 2|\psi_0\rangle\langle\psi_0|
$$
(17)
这可以被识别为Grover的“关于平均值的反转”迭代。这个选择也产生了一个振荡的多项式，它单调地增加矩阵元，直到$d \approx \pi/(2\sin^{-1}a)$步 [37]。这可以通过注意到信号旋转算符的每次应用都使状态旋转一个角度$2\sin^{-1}a$，而目标态最多相距$\pi$角度来看出，这与文献[18]中推导Grover算法查询复杂度的论证类似。因此，振幅放大算法在这个极限下给出了Grover的量子搜索算法，所需的预言机调用次数为$d \approx \pi/(2\sin^{-1}a) = \pi/[2\sin^{-1}(1/\sqrt{N})] = O(\sqrt{N})$，这是Grover算法已知的性能。

再一次，一个类似的结果在第三节中被讨论，在那里从量子比特化到QSVT再到定点振幅放大的流程被更普遍地应用。


### C. 量子特征值变换 (Quantum eigenvalue transforms)
定理2被称为**振幅放大**，因为它完成了一个特定振幅的多项式变换，即$U$在$|A_0\rangle\langle B_0|$上的矩阵元。然而，这种多项式变换实际上可以**作用于整个向量空间**，而不仅仅是一个一维的矩阵元。特别地，我们现在展示这项技术可以用来对一个已被嵌入到幺正矩阵$U$块中的哈密顿量$H$的所有特征值进行多项式变换。

具体来说，假设我们有幺正矩阵
$$
U = \begin{array}{c|cc} & 0 & 1 \\ \hline 0 & H & \cdot \\ 1 & \cdot & \cdot \end{array}
$$
(18)
其中$H$是某个$N \times N$（可能非常大）的哈密顿量算符，位于$U$的左上角块，由一个索引量子比特处于状态$|0\rangle$来标记（因此可以说$H$已经被“量子比特化”了）。我们在$U$的矩阵表示旁边标注了索引0和1，以示意性地指示$H$是如何在$U$中编码的。为了简化说明，我们牺牲一些普适性做一些假设。特别地，假设算符范数$\|H\|$足够小，使得这种块编码可以实现，即$\|H\| \le 1$（如果不是，可以转而嵌入某个缩放版本的哈密顿量$H/\alpha$，但为了阐述清晰，我们暂时忽略这种情况）。特别地，假设$H$的本征向量和本征值为
$$
H = \sum_\lambda \lambda |\lambda\rangle\langle\lambda|
$$
(19)
然后，为了清晰起见，我们特化到一个具体的块编码，$U$的缺失块可以被补全为
$$
U = \begin{bmatrix} H & \sqrt{I-H^2} \\ \sqrt{I-H^2} & -H \end{bmatrix}
$$
(20)
其中
$$
\sqrt{I-H^2} = \sum_\lambda \sqrt{1-\lambda^2} |\lambda\rangle\langle\lambda|
$$
(21)
通过检验可以看出，只要特征值$\lambda$的尺度合理，$U^\dagger U = I$，满足$U$的幺正性要求。虽然一个通用的块编码**不必采取这种特殊形式**，但这种编码方式对于我们的说明性目的已经足够了。此外，关于通用块编码的处理在文献[8,12]中有介绍，其中指出，一个通用的块编码在一个与$H$的本征基相关的特殊基中，会呈现出与公式(20)相似的形式。

我们选择的这种特殊的块编码意味着$U$可以被表示为两个张量积的和，
$$
U = Z \otimes H + X \otimes \sqrt{I-H^2}
$$
(22)
因此它的作用为
$$
U|0\rangle|\lambda\rangle = \lambda|0\rangle|\lambda\rangle + \sqrt{1-\lambda^2}|1\rangle|\lambda\rangle
$$
(23)
$$
U|1\rangle|\lambda\rangle = -\lambda|1\rangle|\lambda\rangle + \sqrt{1-\lambda^2}|0\rangle|\lambda\rangle
$$
(24)
这表明$U$对$H$的每个对应于特定特征值的本征空间[38]都包含一个布洛赫球（即一个量子比特基）。特别地，$U$可以被表示为$N$个分离的**布洛赫球的直和**：
$$
U = \bigoplus_\lambda \begin{bmatrix} \lambda & \sqrt{1-\lambda^2} \\ \sqrt{1-\lambda^2} & -\lambda \end{bmatrix} \otimes |\lambda\rangle\langle\lambda| = \bigoplus_\lambda [\sqrt{1-\lambda^2}X + \lambda Z] \otimes |\lambda\rangle\langle\lambda| =: \bigoplus_\lambda R(\lambda) \otimes |\lambda\rangle\langle\lambda|
$$
(25)
其中$R(\lambda)$定义为上面倒数第二行方括号中的算符，并且可以被解释为绕布洛赫球y轴的反射和旋转，这与我们在振幅放大构造中根据公式(12)得到的算符$R(a)$完全相同。因此，我们得到了一个与振幅放大情景平行的$U$的形式。然而，与振幅放大不同，我们没有一维的相旋转算符$A_\phi$和$B_\phi$，因为我们有$N$个布洛赫球，而不仅仅是两个。

尽管如此，$H$的输入和输出所在的向量空间仍然是截然不同的：它们分别是$H$的列空间和行空间，在$U$内部。在公式(18)的情景中，这些向量空间由作用在辅助量子比特上的投影算符$\Pi := |0\rangle\langle 0|$来定义。推广振幅放大中使用的作用于单个元素$|A_0\rangle\langle A_0|$的相移$A_\phi$（公式(5)）的方法，我们现在可以定义一个投影算符控制的相移操作$\Pi_\phi$：
$$
\Pi_\phi := e^{i2\phi\Pi}
$$
(26)
它将一个相位$e^{i2\phi}$赋予由投影算符$\Pi$确定的整个子空间。注意，如果我们想更精确，可以转而定义这个操作为
$$
\Pi_\phi := e^{i\phi(2\Pi-I)}
$$
(27)
这是一个规范的幺正变换，作用如同一个z旋转，类似于公式(2)中的$S(\phi)$，但这两个定义仅相差一个可以忽略的全局相位。从量子电路的角度看，$\Pi_\phi$可以通过在单个量子比特绕z轴旋转角度$\phi$的操作前后各加上两个投影算符控制的非门（我们称之为$\Pi$-controlled-NOT，或简写为$C_\Pi \text{NOT}$）来实现，如图3所示：

主要的相关观察是，在公式(25)中$N$个布洛赫球的每一个子空间上，$\Pi_\phi$都像一个z轴旋转一样作用，
$$
\Pi_\phi = \bigoplus_\lambda e^{i\phi Z} |\lambda\rangle\langle\lambda|
$$
(28)
其中$|\lambda\rangle$是其本征向量。

这幅描绘$N$个分离的布洛赫球在z和y旋转下演化的图像，为以下定理提供了直观基础：

**定理3（特征值变换）**: 给定哈密顿量$H = \sum_\lambda \lambda |\lambda\rangle\langle\lambda|$在一个幺正矩阵$U$中的块编码，
$$
U =  \begin{bmatrix} H & \cdot \\ \cdot & \cdot \end{bmatrix}
$$
(29)
其中$H$的位置由投影算符$\Pi$确定，并给定执行$\Pi$-controlled-NOT操作以实现投影算符控制的相移操作$\Pi_\phi$的能力，那么，对于偶数$d$，
$$
U_{\vec{\phi}} = \left[\prod_{k=1}^{d/2} \Pi_{\phi_{2k-1}} U^\dagger \Pi_{\phi_{2k}} U \right] =  \begin{bmatrix} \text{Poly}(H) & \cdot \\ \cdot & \cdot \end{bmatrix}
$$
(30)
其中
$$
\text{Poly}(H) = \sum_\lambda \text{Poly}(\lambda) |\lambda\rangle\langle\lambda|
$$
(31)
是对$H$的特征值进行的多项式变换。该多项式的阶数最多为$d$且满足定理1中对$P$的条件。
类似地，对于奇数$d$，
$$
U_{\vec{\phi}} = \Pi_{\phi_1} U \left[\prod_{k=1}^{(d-1)/2} \Pi_{\phi_{2k}} U^\dagger \Pi_{\phi_{2k+1}} U \right] = \begin{bmatrix} \text{Poly}(H) & \cdot \\ \cdot & \cdot \end{bmatrix}
$$
(32)
其中$\text{Poly}(H)$有类似的解释。

这为什么能行？原因与定理2相同。为了看到这一点，让我们使用公式(20)的特定编码将公式(30)重写为作用在$N$个分离的布洛赫球上的形式（奇数$d$的情况在公式(32)中是类似的）：
$$
U_{\vec{\phi}} = \bigoplus_\lambda \left[\prod_{k=1}^{d/2} e^{i\phi_{2k-1}Z} R(\lambda) e^{i\phi_{2k}Z} R(\lambda) \right]
$$
(33)
认识到我们在公式(25)中为$R(\lambda)$选择的约定使得$R^\dagger(\lambda) = R(\lambda)$。这允许我们重标号求和与相位，将公式(33)写成量子信号处理的标准形式（类似于我们得到公式(15)的方式）：
$$
U_{\vec{\phi}} = \bigoplus_\lambda \left[e^{i\phi'_0 Z} \prod_{k=1}^{d} W(\lambda) e^{i\phi'_k Z} \right]
$$
(34)
根据定理1，方括号中的项是一个关于$\lambda$的多项式矩阵，从而验证了定理3。最后，虽然我们特化到了公式(20)的具体块编码，但对于更通用块编码的证明包含在文献[8,12]中。

这个特征值变换定理一个立即可见的用处是它在筛选特征值方面的有效性。例如，我们在第二节A中看到，BB1相位序列可以用来增加对信号的敏感性。在这个特征值变换情景中，信号是特征值$\lambda$，一串QSP相位可以被用来选择性地筛选一个范围内的特征值，例如，在BB1的情况下，是那些低于阈值$\lambda \approx 2\pi/3$的特征值（目前这是一个不精确的陈述，但类似的问题是第四节的主要关注点）。测量投影算符$\Pi$将显示，如果哈密顿量有一个大于此阈值的特征值，QSP序列会以更高的概率翻转索引量子比特，而当$H$的所有特征值都低于此阈值时则不然。这个结果还假设能够制备一个与$H$的相关本征态有一定交叠的态作为$U$的输入，但交叠的具体幅度并不关键，因为可以采用振幅放大来增强信号。
### D. 量子奇异值变换 (Quantum singular value transforms)
定理3被称为**特征值变换**，因为它完成了对一个嵌入在更大幺正矩阵中的矩阵的特征值的多项式变换。然而，一般情况下，嵌入的矩阵不一定有定义良好的特征值集；例如，它可能是一个长方形矩阵而非方阵。值得注意的是，使用量子信号处理来变换嵌入矩阵的同样思想仍然适用。具体来说，我们现在展示QSP序列可以被用来对一个已被编码到幺正矩阵$U$块中的（可能是非方阵的）矩阵$A$的所有奇异值进行多项式变换。

这样一个通用矩阵$A$可以被分解为
$$
A = W_\Sigma \Sigma V_\Sigma^\dagger
$$
(35)
其中$W_\Sigma$和$V_\Sigma$是幺正矩阵，$\Sigma$是对角矩阵，其对角线上包含非负实数集合$\{\sigma_k\}$，被称为$A$的**奇异值**，其中有$r=\text{rank}(A)$个非零值。所有矩阵都具有这样的**奇异值分解** (**SVD**)。

由于$W_\Sigma$和$V_\Sigma$是幺正的，它们的列构成了标准正交基，我们分别记为$\{|w_k\}\rangle$和$\{|v_k\}\rangle$。$\{|w_k\}\rangle$是**左奇异向量**，张成左奇异向量空间；$\{|v_k\}\rangle$是**右奇异向量**，张成右奇异向量空间。使用这个记法，我们可以方便地将$A$的奇异值分解重写为一种类似于特征值分解的形式：
$$
A = \sum_{k=1}^r \sigma_k |w_k\rangle\langle v_k|
$$
(36)
现在，假设我们被给定一个幺正矩阵$U$，使得$A$被编码在$U$的一个块中，即：
$$
U = \begin{array}{c|cc} & \Pi & \\ \hline \tilde{\Pi} & A & \cdot \\ & \cdot & \cdot \end{array}
$$
(37)
其中$\tilde{\Pi} := \sum_k |w_k\rangle\langle w_k|$和$\Pi := \sum_k |v_k\rangle\langle v_k|$是定位$A$在$U$中位置的投影算符，使得$A = \tilde{\Pi} U \Pi$。我们再次在矩阵表示旁边标注了$\Pi$和$\tilde{\Pi}$索引，以示意性地指示$A$是如何在$U$中编码的：$\Pi$选择了$A$所在的列，$\tilde{\Pi}$选择了所在的行。此外，投影算符$\Pi$和$\tilde{\Pi}$也分别标识了右奇异和左奇异向量空间。

为了教学上的简化，我们暂时假设$A$是一个方阵（这个假设将在下一节中被放弃）。再次特化到一个具体的块编码，我们可以通过写出以下形式来补全幺正矩阵$U$的缺失块：
$$
U = \begin{array}{c|cc} & 0 & 1 \\ \hline 0 & A & \sqrt{I-A^2} \\ 1 & \sqrt{I-A^2} & -A \end{array}
$$
(38)
其中0和1是$U$内部块矩阵的索引量子比特标签，而$\sqrt{I-A^2}$是根据$A$的SVD**形式化定义**的：
$$
\sqrt{I-A^2} := \sum_k \sqrt{1-\sigma_k^2} |w_k\rangle\langle v_k|
$$
(39)
然后可以直接验证$U^\dagger U = I$，只要奇异值$\{\sigma_k\}$小于等于1（这总可以通过将$A$缩放为某个$A/\alpha$来实现）。再次强调，虽然一个通用的块编码不必采取这种特殊形式，但这个选择对于我们的说明性目的已经足够了。而且，通用块编码的处理在文献[12]中有介绍，其中指出，一个通用的块编码在一个与$A$的左右奇异向量相关的特殊基中，会呈现出与公式(38)相似的形式。

正如对块编码哈密顿量$H$的分析一样，$U$中也存在多个布洛赫球。具体来说，注意到
$$
U|0\rangle|v_k\rangle = \sigma_k|0\rangle|w_k\rangle + \sqrt{1-\sigma_k^2}|1\rangle|w_k\rangle
$$
(40)
$$
U|1\rangle|v_k\rangle = -\sigma_k|1\rangle|w_k\rangle + \sqrt{1-\sigma_k^2}|0\rangle|w_k\rangle
$$
(41)
所以$U$可以被表示为等于$A$的秩的多个分离布洛赫球的直和：
$$
U = \bigoplus_k \begin{bmatrix} \sigma_k & \sqrt{1-\sigma_k^2} \\ \sqrt{1-\sigma_k^2} & -\sigma_k \end{bmatrix} \otimes |w_k\rangle\langle v_k| = \bigoplus_k [\sqrt{1-\sigma_k^2}X + \sigma_k Z] \otimes |w_k\rangle\langle v_k| =: \bigoplus_k R(\sigma_k) \otimes |w_k\rangle\langle v_k|
$$
(42)
其中我们定义的$R(\sigma_k)$与公式(25)中的$R(\lambda)$是类似的。我们现在得到了一个与特征值变换情景直接平行的$U$的形式，并且基于完全相同的原因，以下定理成立：

**定理4（奇异值变换）**: 给定一个幺正矩阵$U$中矩阵$A = \sum_k \sigma_k |w_k\rangle\langle v_k|$的块编码
$$
U = \begin{array}{c|cc} & \Pi & \\ \hline \tilde{\Pi} & A & \cdot \\ & \cdot & \cdot \end{array}
$$
(43)
其中$A$的位置由投影算符$\Pi$和$\tilde{\Pi}$确定，并给定执行$\Pi$-和$\tilde{\Pi}$-controlled-NOT操作以实现投影算符控制的相移操作$\Pi_\phi$和$\tilde{\Pi}_\phi$（定义如第二节C）的能力，那么，对于奇数$d$，
$$
U_{\vec{\phi}} = \tilde{\Pi}_{\phi_1} U \left[ \prod_{k=1}^{(d-1)/2} \Pi_{\phi_{2k}} U^\dagger \tilde{\Pi}_{\phi_{2k+1}} U \right] = \begin{array}{c|cc} & \Pi & \\ \hline \tilde{\Pi} & \text{Poly}^{(\text{SV})}(A) & \cdot \\ & \cdot & \cdot \end{array}
$$
(44)
其中$\text{Poly}^{(\text{SV})}(A)$对于奇数多项式定义为
$$
\text{Poly}^{(\text{SV})}(A) := \sum_k \text{Poly}(\sigma_k) |w_k\rangle\langle v_k|
$$
(45)
它对$A$的奇异值施加了一个多项式变换。该多项式的阶数最多为$d$且满足定理1中对$P$的条件。
类似地，对于偶数$d$，
$$
U_{\vec{\phi}} = \left[ \prod_{k=1}^{d/2} \Pi_{\phi_{2k-1}} U^\dagger \tilde{\Pi}_{\phi_{2k}} U \right] = \begin{array}{c|cc} & \Pi & \\ \hline \Pi & \text{Poly}^{(\text{SV})}(A) & \cdot \\ & \cdot & \cdot \end{array}
$$
(46)
其中$\text{Poly}^{(\text{SV})}(A)$对于偶数多项式定义为
$$
\text{Poly}^{(\text{SV})}(A) := \sum_k \text{Poly}(\sigma_k) |v_k\rangle\langle v_k|
$$
(47)
这也是对$A$的**奇异值的多项式变换**，但有一个修改，即输入和输出空间都是由$\{|v_k\rangle\}$张成的右奇异向量空间。类似地，该多项式的阶数最多为$d$且满足定理1中对$P$的条件。

这个定理与特征值变换的定理3之间的主要区别在于，这里的布洛赫球变换$U$也在$\{|v_k\rangle\}$和$\{|w_k\rangle\}$基之间切换，类似于定理2中的序列[公式(13)]在不同基之间翻转。因此，我们现在应该仔细地追踪系统在每个操作阶段处于哪个向量空间。特别地，在公式(46)和(44)的方括号中的每一项中，右边的$U$将系统从$\{|v_k\rangle\}$基移动到$\{|w_k\rangle\}$基，然后$\tilde{\Pi}_\phi$将系统绕每个左奇异向量空间的布洛赫球的z轴旋转。类似地，左边的$U^\dagger$将系统从$\{|w_k\rangle\}$基移回到$\{|v_k\rangle\}$基，最后，$\Pi_\phi$将系统绕每个右奇异向量空间的布洛赫球的z轴旋转。因此，奇数$d$的序列从右奇异向量空间开始，结束于左奇异向量空间，这样$\text{Poly}^{(\text{SV})}(A)$可以通过$\Pi$和$\tilde{\Pi}$来访问；而偶数$d$的序列在右奇异向量空间开始和结束，这样$\text{Poly}^{(\text{SV})}(A)$仅通过$\Pi$来访问。

通过这个关键的修改，定理4可以通过与定理3相同的逻辑来验证，而对通用块编码的证明则在文献[12]中给出。定理4是QSVT算法的精髓，我们将在接下来的章节中详细阐述用它可以完成什么。

### E. 块编码 (Block encodings)
将QSP从单量子比特动力学推广到多量子比特变换的一个关键思想是使用**块编码算符**，正如我们在前两个小节中刚刚看到的那样（并将在后续章节中讨论）。虽然将一个矩阵嵌入到一个更大的矩阵中的做法在数学上作为一种**扩张** (dilation) [39] 是众所知的，但在这里使用的块编码算符是一个量子概念，它们的构造附带一些注意事项。我们在本小节中详细阐述这些构造。

许多QSP和QSVT应用的起点是能够获得作为线性算符（一个矩阵$A$）的期望信号，该信号被编码在一个更大的幺正矩阵$U$的一个块中，如公式(37)所述。从物理上讲，这样一个块编码算符是什么？当$A$是一个幺正矩阵时，可以获得一些有限的直觉，在这种情况下$U$仅仅是一个受控-$A$算符，如图4所示。

当$A$是一个大算符时，要想象一个受控-$A$操作如何能够被物理实现是具有挑战性的。

**图4**: 一个简单的块编码量子电路，展示了这样一个酉算符$A$的块编码是如何被标记的。观察到控制量子比特（顶线）上的空心圆表示$|0\rangle$控制，而实心圆则对应于$|1\rangle$控制。

**图5**: 给定对$A$的一个(+1)本征向量$|\lambda\rangle$的访问权限，构造$|1\rangle$-controlled-$A$（对于一个单比特算符$A$）的示意图。$|\xi\rangle$是控制量子比特，$|\psi\rangle$是目标态。注意，$A$通常可能作用于一个大的希尔伯特空间，在这种情况下，受控交换(controlled-swap)算符需要被适当地推广。交换操作可以被设置为$|0\rangle$控制，以模拟图4。我们注意到这与文献[40]中用于矩阵元测量的电路有相似的构造。

特别地，给定$A$，如何在没有进一步信息的情况下构造一个受控-$A$操作通常是不可能的。例如，如果提供了$A$的一个+1本征态$|\lambda\rangle$，那么一个受控-$A$量子电路可以通过使用$|\lambda\rangle$以及两个受控-SWAP门来构造（见图5）。然而，在一般情况下，实现一个块编码需要做更多的工作，通常是以与相关物理系统特定的方式 [12,40]。

与块编码问题相关的是访问被编码块的期望多项式变换。如第二节A所述，在执行一个QSP-QSVT序列后，可以在信号基中进行测量，以确定期望的多项式变换是否被实现。特别地，在许多算法中，我们希望将变换后的算符$\text{Poly}^{(\text{SV})}(A)$应用于某个态$|\psi\rangle$，这可以通过使用块编码$U_{\vec{\phi}}$来完成。然而，这个计算只有在我们对$|\psi\rangle$应用正确的块即编码$\text{Poly}^{(\text{SV})}(A)$的那个块时才会成功，所以我们必须通过使用被假定为可访问的投影算符$\Pi$和$\tilde{\Pi}$进行投影测量，将最终状态投影到这个块中。因此，对于单辅助量子比特的QSVT，相关的投影算符通常是$|+\rangle\langle+| \otimes \Pi$，它既(1)分离出第二节A中讨论的变换多项式$P$的实部，又(2)确定我们是否应用了整个幺正矩阵的期望块。由于这个投影测量是在算法结束时进行的一次性投影，其成本不大，而且，投影测量产生期望状态的概率可以通过振幅放大或经典重复来放大。根据构造的不同，这个概率既可以是期望的输出，也可以是一个在算法上有用的输出。关于信号基和QSP约定的更多信息，请参见附录A。


### VI. 通过QSVT解决函数求值问题 (FUNCTION-EVALUATION PROBLEMS BY QSVT)

QSVT的另一个有用应用是求值作用于一个矩阵的函数，我们称之为**函数求值问题**。示意性地来说，如果$f(x)$是我们感兴趣的函数，而我们希望评估$f(A)$，那么我们可以想象通过采用一个近似于$f(x)$的多项式$P(x)$并利用QSVT来解决这个问题。虽然这类问题通常用量子特征值变换来处理会更容易入手，但用QSVT来解决它们也同样直接明了。

在这里，我们总结一些著名的函数评估问题，最值得注意的是**哈密顿量模拟**和**矩阵求逆**。我们的讨论总结了文献[12]中的结果，其中可以找到这些过程的全部细节。
好的，这是对“Hamiltonian simulation by QSVT”部分的完整翻译：

### A. 通过QSVT进行哈密顿量模拟 (Hamiltonian simulation by QSVT)
量子计算的一个激励性目标是模拟一个态在哈密顿量下的时间演化，这个问题被称为**哈密顿量模拟**。也就是说，对于一个哈密顿量$H$和某个时间$t$，我们希望近似时间演化算符$e^{-iHt}$，这显然是一个函数评估问题，其函数为$f(x) = e^{-ixt}$。

在这个问题的设定中，我们假设可以访问$H$，并希望为其构建一个幺正块编码，以便我们可以用QSVT解决这个问题。然而，正如我们在第四节讨论的，这样的幺正块编码仅在$\|H\| \le 1$时才可实现。因此，在一般情况下，我们转而确定一个$\alpha \ge \|H\|$并构造$H/\alpha$的幺正块编码。同样，这需要一些关于$H$的先验知识，我们将在第七节详细阐述这个缺点，但幸运的是，对于一大类哈密顿量，这样的块编码是可以实现的 [8,12]。

有了这个重新缩放的块编码，我们可以等价地想象我们的目标是模拟一个系统在重新缩放的哈密顿量$H/\alpha$下演化时间$t\alpha$。这个等价性成立是因为相应的时间演化算符是相同的：$e^{-i(H/\alpha)(\alpha t)} = e^{-iHt}$。

这个问题如何用QSVT解决呢？一个直观的想法是尝试使用QSVT和一个近似于$e^{-ixt}$的多项式（在这里，我们视$t$为参数，而非变量）。然而，由于指数函数没有确定的奇偶性，这个函数不满足在第二节A和附录A中讨论的对$\text{Poly}(a) = \langle+|U_{\vec{\phi}}|+\rangle$的约束。为了规避这个问题，我们可以转而应用QSVT两次——一次用一个偶数多项式近似$\cos(xt)$，另一次用一个奇数多项式近似$\sin(xt)$，这两者都具有确定的奇偶性。然后，使用图17所示的电路，我们可以将这两个QSVT执行的结果加在一起，得到$\cos^{(\text{SV})}(Ht) - i\sin^{(\text{SV})}(Ht) = e^{-iHt}$，如愿以偿。

然而，请注意上述关系仅在$H$的特征值为正时才成立，这样奇异值才等于特征值。正如我们在第四节讨论的，如果情况并非如此，我们可以转而使用$H/\alpha$的块编码和一个类似于图10的电路来构造正定矩阵$\frac{1}{2}(\frac{H}{\alpha}+I)$的块编码。对这个矩阵应用上述QSVT过程演化时间$2\alpha t$，会产生一个$e^{-iHt}$的块编码，最多相差一个全局相位。在本节的其余部分，我们假设这个问题已得到缓解。

回到QSVT方案，我们注意到在文献[12]中，Gilyén等人使用雅可比-安格展开(Jacobi-Anger expansion)的多项式来近似函数$\cos(xt)$和$\sin(xt)$：
$$
\cos(xt) = J_0(t) + 2\sum_{k=1}^\infty (-1)^k J_{2k}(t)T_{2k}(x)
$$
(76)
$$
\sin(xt) = 2\sum_{k=0}^\infty (-1)^k J_{2k+1}(t)T_{2k+1}(x)
$$
(77)
其中$J_i(x)$是$i$阶贝塞尔函数，$T_i(x)$是$i$阶切比雪夫多项式。通过在一个足够大的索引$k'$处截断这些表达式，可以获得对$\cos(xt)$和$\sin(xt)$的$\epsilon$近似。必要的截断索引$k'$可以由一个函数$r(t, \epsilon)$确定，该函数被隐式定义为
$$
\epsilon = \left(\frac{|t|}{r(t,\epsilon)}\right)^{r(t,\epsilon)} \text{, 使得 } r(t,\epsilon) \in (t, \infty)
$$
(78)
并渐近地缩放为
$$
r(t, \epsilon) = \Theta\left( |t| + \frac{\log(1/\epsilon)}{\log(e + \frac{\log(1/\epsilon)}{|t|})} \right)
$$
(79)
特别地，在$k'=\lceil\frac{1}{2}r(\epsilon/2|t|, 5/4\epsilon)\rceil$处截断公式(76)和(77)会分别产生对$\cos(xt)$和$\sin(xt)$的$\epsilon$近似，其中$0 < \epsilon < 1/e$。因为$T_i(x)$是一个具有确定奇偶性的$i$次多项式，这些近似分别是阶数为$2k'$和$2k'+1$的多项式，具有正确的偶数或奇数奇偶性。我们用$P_{\cos}(x;t)$和$P_{\sin}(x;t)$来表示这些多项式。

最后，因为余弦和正弦的幅值以1为界，这些$\epsilon$近似只满足$|P_{\cos}(x;t)|, |P_{\sin}(x;t)| \le 1+\epsilon$。然而，我们需要目标多项式的幅值必须以1为界，以便通过QSVT实现。如文献[23]所示，我们可以通过将多项式乘以一个因子$1/(1+\epsilon)$来解决这个问题，代价是将这些近似的误差增加到$2\epsilon$。这可以通过三角不等式看出：$|(1/(1+\epsilon))P_{\cos}(x;t) - \cos(xt)| \le 1/(1+\epsilon)[|P_{\cos}(x;t) - \cos(xt)| + |\epsilon\cos(xt)|] \le 1/(1+\epsilon)(\epsilon+\epsilon) \le 2\epsilon$，对于$P_{\sin}(x;t)$也类似。

**图17**: 一个可用于构建时间演化算符$\cos(Ht) - i\sin(Ht) = e^{-iHt}$并将其应用于$|\psi_0\rangle$的量子电路，用于算法4中所述的哈密顿量模拟。注意，输入态$|\psi_0\rangle$的正确演化仅在对辅助量子比特进行后选择，得到$|0\rangle$态时才能实现。这可以通过重复或定点振幅放大来实现，类似于在第二节D末尾讨论的投影到QSVT序列算符的期望块中。

为了确定这个哈密顿量模拟算法的复杂度，首先回顾我们的有效目标是模拟重新缩放的哈密顿量$H/\alpha$演化时间$\alpha t$。此外，注意在此过程中使用的雅可比-安格展开的截断应该是$\epsilon/4$近似，这样当被$1/(1+\epsilon/4)$重新缩放后，它们成为对$\cos(xt)$和$\sin(xt)$的$\epsilon/2$近似。通过这个选择，这些近似的和，也就是对$e^{-ixt}$的近似，通过三角不等式是$\epsilon$近似的。综合这些条件，我们看到这个基于QSVT的哈密顿量模拟算法制备了一个$e^{-iHt}$的$\epsilon$-近似块编码，并总共查询了$U$
$$
2k' + 2k' + 1 \approx 4 \cdot \frac{1}{2} r\left(\frac{\epsilon}{2\alpha|t|}, \frac{5}{4}\epsilon\right) + 1 = O\left(\alpha|t| + \frac{\log(1/\epsilon)}{\log(e + \frac{\log(1/\epsilon)}{\alpha|t|})}\right)
$$
(80)
次。

在将此查询复杂度与文献中引用的结果进行比较时，$\alpha$可以被替换为$\|H\|$。

这个复杂度在$t$和$\epsilon$上的扩展性达到了哈密顿量模拟的现有技术水平：它在$t$上是线性的，在$1/\epsilon$上是对数的，并且在这两项上是相加的。因此，它比其他算法[8,12,23]有显著的改进。我们在算法4中总结了通过QSVT进行的哈密顿量模拟。

#### 用QSVT来实现量子模拟的总结
好的，根据这篇文章，使用**量子奇异值变换 (QSVT)** 来进行**哈密顿量模拟** (Hamiltonian Simulation) 的核心思想是：将时间演化算符 $e^{-iHt}$ 分解为其三角函数部分 $\cos(Ht)$ 和 $\sin(Ht)$，然后利用QSVT强大的函数构造能力，分别用多项式来逼近这两个函数，最后再将它们巧妙地组合起来。

以下是详细的步骤和解释：

##### 1. 问题设定：函数评估

哈密顿量模拟的目标是实现幺正演化 $U(t) = e^{-iHt}$。
这可以被看作一个**函数评估问题**，其中目标函数是指数函数 $f(x) = e^{-ixt}$，我们希望将这个函数作用于哈密顿量 $H$ 的特征值。

##### 2. 挑战：奇偶性不匹配

一个直接的想法是：找到一个多项式 $P(x)$ 来近似 $e^{-ixt}$，然后用QSVT直接实现 $P(H)$。
然而，这个想法行不通，因为 $e^{-ixt}$ 这个复指数函数**没有确定的奇偶性**（它既不是偶函数也不是奇函数）。而标准的QSVT构造（特别是当我们需要得到一个实数多项式近似时，即$\text{Poly}(a) = \langle+|U_{\vec{\phi}}|+\rangle$）要求目标多项式必须具有确定的奇偶性（要么是偶函数，要么是奇函数）。

##### 3. 解决方案：分解与重组

为了解决奇偶性问题，文章采用了经典欧拉公式的思想，将目标函数分解：
$$
e^{-iHt} = \cos(Ht) - i\sin(Ht)
$$

这个分解非常巧妙，因为它把一个没有确定奇偶性的函数，分解成了一个**偶函数** ($\cos(Ht)$) 和一个**奇函数** ($\sin(Ht)$) 的线性组合。这两个函数现在都可以用QSVT来处理了。

**具体步骤如下：**

###### 步骤一：构造多项式近似

-   **为 $\cos(xt)$ 找一个偶数多项式**: 文章指出，可以使用**雅可比-安格展开 (Jacobi-Anger expansion)**，这是一个将三角函数表示为贝塞尔函数 ($J_k$) 和切比雪夫多项式 ($T_k$) 无穷级数的方法。通过截断这个级数，可以得到一个阶数为 $2k'$ 的**偶数多项式** $P_{\cos}(x;t)$，它能以任意精度 $\epsilon$ 逼近 $\cos(xt)$。
-   **为 $\sin(xt)$ 找一个奇数多项式**: 同样地，利用雅可比-安格展开，可以得到一个阶数为 $2k'+1$ 的**奇数多项式** $P_{\sin}(x;t)$ 来逼近 $\sin(xt)$。

###### 步骤二：块编码与缩放

-   **块编码**: 算法的前提是，我们拥有哈密顿量 $H$ 的一个块编码 $U_H$。通常情况下，我们只能构造一个重新缩放后的哈密顿量 $H/\alpha$ 的块编码，其中 $\alpha \ge \|H\|$。
-   **时间缩放**: 这意味着我们的实际目标是模拟 $e^{-i(H/\alpha)(\alpha t)}$，即用 $H/\alpha$ 演化时间 $\alpha t$。因此，上面多项式中的变量$t$实际上被替换为$\alpha t$。

###### 步骤三：用QSVT实现多项式

现在，我们可以执行两次独立的QSVT过程：
1.  **第一次QSVT**: 使用为 $\cos(\alpha t \cdot x)$ 设计的相位角序列 $\vec{\phi}_{\cos}$，作用于块编码 $U_{H/\alpha}$，从而得到一个近似实现 $\cos(H t)$ 的操作。
2.  **第二次QSVT**: 使用为 $\sin(\alpha t \cdot x)$ 设计的相位角序列 $\vec{\phi}_{\sin}$，作用于块编码 $U_{H/\alpha}$，从而得到一个近似实现 $\sin(H t)$ 的操作。

###### 步骤四：线性组合电路

最后，需要将这两个操作的结果组合起来。文章中的 **图17** 展示了如何做到这一点。这个电路使用一个辅助量子比特，通过受控地执行 $\cos(Ht)$ 操作和 $-i\sin(Ht)$ 操作，然后进行后选择（post-selection）或振幅放大，最终在目标寄存器上实现 $e^{-iHt}$ 的演化。

具体来说，如果辅助比特处于 $|0\rangle$，则电路的效果是 $(\cos(Ht) - i\sin(Ht))|\psi_0\rangle = e^{-iHt}|\psi_0\rangle$。

### 关键优势

这种基于QSVT的哈密顿量模拟方法具有**目前最优的复杂度**：
-   **线性时间依赖**: 模拟时间越长，复杂度线性增加，这是最优的。
-   **对数精度依赖**: 要求的精度越高（即 $\epsilon$ 越小），复杂度仅以 $\log(1/\epsilon)$ 的形式增加，这远优于之前算法的多项式依赖。

**总结**:

QSVT通过一种“分而治之”的策略实现了哈密顿量模拟。它将一个不满足QSVT奇偶性约束的复杂函数 ($e^{-ixt}$) 分解为两个满足约束的简单函数 ($\cos(xt)$ 和 $\sin(xt)$)，然后利用QSVT的通用性分别构造这两个函数的多项式近似，最后通过一个简单的量子电路将它们重新组合，从而以极高的效率和精度完成了模拟任务。这完美地展示了QSVT作为一个通用函数评估引擎的强大威力。

### B. 通过QSVT进行矩阵求逆 (Matrix inversion by QSVT)
另一个直接且应用广泛的函数评估问题是**矩阵求逆**。也就是说，给定一个方阵$A$，我们希望构造一个对$A^{-1}$的近似。Harrow等人在$A$是厄米矩阵的情况下提出了一个解决此问题的量子算法[15]。在他们同名的算法中，他们制备了态$A^{-1}|b\rangle$，这为线性系统$A|x\rangle=|b\rangle$提供了一个量子解。

现在让我们通过QSVT的视角来看待这个问题。假设我们有一个$N \times N$的矩阵$A$，其奇异值分解为$A = W_\Sigma \Sigma V_\Sigma^\dagger$，其中$\Sigma$的对角线上包含了奇异值。按照HHL算法的设定，我们还假设$A$的奇异值$\sigma_i$满足$\sigma_i \in [1/\kappa, 1]$，其中$\kappa \ge 1$是某个有限的**条件数**（如果不满足，可以对$A$进行缩放以满足此条件）。由于奇异值非零，$A$的逆存在，并可以表示为$A^{-1} = V_\Sigma \Sigma^{-1} W_\Sigma^\dagger$，其中$\Sigma^{-1}$的对角线上包含了奇异值的倒数。因为$A^\dagger = V_\Sigma \Sigma W_\Sigma^\dagger$，这可以被重写为$A^{-1} = f^{(\text{SV})}(A^\dagger)$，其中$f(x) = 1/x$，这表明矩阵求逆是一个函数评估问题，其函数为$f(x)=1/x$。

意识到这一点后，如何应用QSVT来进行矩阵求逆就变得清晰了：找到一个奇数多项式$P(x)$，它在$A$的奇异值范围内近似于$f(x)=1/x$，然后利用QSVT构造$P^{(\text{SV})}(A^\dagger)$，它将近似于$A^{-1}$。由于$1/x$函数的不连续性，找到一个好的多项式$P(x)$是棘手的，但这确实可以做到。此外，这个过程要求我们能构造一个$A$的幺正块编码，根据$\sigma_i \le 1$的假设，这是可行的因为$\|A\| \le 1$。这样的块编码确实可以为物理学中相关的各种矩阵实现[8,12]（但同样，我们将在第七节讨论这样做的一些注意事项）。

此外，因为我们要求多项式$P(x)$的幅值以1为界才能通过QSVT实现，我们不一定能使用$P(x) \approx 1/x$作为我们的目标函数，因为一般情况下$1/\sigma_i \ge 1$。为了克服这个挑战，我们转而寻求一个函数的多项式近似，该函数的行为类似于在区间$[-1, 1] \setminus [-1/\kappa, 1/\kappa]$上的$1/(2\kappa) \cdot 1/x$，

**算法4. 通过QSVT进行哈密顿量模拟**
**输入**: 对哈密顿量$H$的访问，一个期望的时间$t$，一个误差容限$\epsilon$，以及一个$\alpha \ge \|H\|$。
**输出**: $e^{-iHt}$的一个块编码$\epsilon$-近似。
**运行时间**: $\Theta\left(\alpha|t| + \frac{\log(1/\epsilon)}{\log(e+\log(1/\epsilon)/\alpha|t|)}\right)$次对$H/\alpha$的（编码）查询。
**步骤**:
1. 准备$H/\alpha$的一个幺正块编码。
2. 对这个编码应用QSVT两次，分别使用多项式$\frac{1}{1+\epsilon/4}P^{\cos}_{\epsilon/4}(x;t)$和$\frac{1}{1+\epsilon/4}P^{\sin}_{\epsilon/4}(x;t)$，其中$P^{\cos}_{\epsilon/4}(x;t)$和$P^{\sin}_{\epsilon/4}(x;t)$是通过在索引$k' = \lceil\frac{1}{2}r(\epsilon/2\alpha|t|, 5\epsilon/4)\rceil$处截断公式(76)和(77)中的级数得到的。
3. 利用上述QSVT执行的结果，它们分别近似于$\cos^{(\text{SV})}(Ht)$和$\sin^{(\text{SV})}(Ht)$，运行图17中的电路。

它会对每个奇异值求逆并且在该范围内的幅值以$1/2$为界（我们使用乘法因子$1/(2\kappa)$而不是$1/\kappa$，以避免像在第六节A中那样需要用$1/(1+\epsilon)$重新缩放）。这个过程将输出$(1/(2\kappa))A^{-1}$的一个近似，并且因为$\kappa$是先验已知的，这个乘法因子不会对计算造成阻碍。然而，由于这个乘法因子，我们现在需要一个对$(1/(2\kappa))A^{-1}$的$\epsilon/(2\kappa)$近似，从而我们能有效地得到一个对$A^{-1}$的$\epsilon$近似。

因此，用于矩阵求逆的合适多项式是对$1/(2\kappa) \cdot 1/x$的$\epsilon/(2\kappa)$近似。在附录C中，我们展示了如何构造这样一个多项式。虽然构造过程有点复杂，但本质上它是一个在限定范围内近似$1/x$的多项式（由切比雪夫多项式的和构造）与一个近似矩形函数的多项式（由符号函数近似$P_{\epsilon,\Delta}(x)$的和构造）的乘积。

我们称这个多项式为**矩阵求逆多项式**，记为$P^{\text{MI}}_{\epsilon,\kappa}(x)$，并将其严格定义推迟到附录C。除了作为对$(1/(2\kappa))1/x$的$\epsilon/(2\kappa)$近似之外，$P^{\text{MI}}_{\epsilon,\kappa}(x)$还具有奇数奇偶性，并且对于$x \in [-1, 1]$，其幅值以1为界。因此，矩阵求逆多项式可以通过QSVT实现。此外，我们还在附录C中显示$P^{\text{MI}}_{\epsilon,\kappa}(x)$的阶数为
$$
d=O[\kappa \log(\kappa/\epsilon)]
$$
(81)
由于QSVT需要$O(d)$次对块编码的调用，我们看到通过QSVT进行矩阵求逆的复杂度为$O[\kappa \log(\kappa/\epsilon)]$。这比传统的HHL算法有所改进，后者的运行时间为$O[\kappa^2\log(N)/\epsilon]$。QSVT算法在$\kappa/\epsilon$的扩展性上提供了巨大的改进，这是非常令人印象深刻的，尽管类似的结果也已通过非QSVT方法实现[50]。此外，HHL算法使用了一个以目标哈密顿量$A$为基础的稀疏哈密顿量模拟子程序，导致其复杂度中出现了$\log(N)$项，而QSVT算法不使用这样的子程序，因此其复杂度中没有$N$的依赖性（然而，构造所需的$A$的块编码可能会随$N$扩展）。我们在算法5中总结了通过QSVT进行的矩阵求逆。

此外，与HHL算法一样，通过QSVT进行的矩阵求逆也可以用于求解线性方程组$A|x\rangle=|b\rangle$，方法是将$(1/(2\kappa))A^{-1}$的块编码应用于$|b\rangle$，在通过$2\kappa$重新缩放后，会产生一个对$A^{-1}|b\rangle$的$\epsilon$近似。如第二节D末尾所讨论的，这个过程要求我们投影到QSVT序列算符的期望块中，这只需很小的开销即可完成。

最后，我们注意到这个结果可以被进一步扩展。通过一些微小的调整，这个基于QSVT的算法可以被修改为制备一个长方形矩阵的伪逆，这在各种机器学习的场景中非常有用[12]。
## 技术

### 关键物理概念

#### Quantum Signal Processing (QSP)
**量子信号处理** (**QSP**) 是一种在单量子比特上实现对信号进行函数变换的技术。其核心思想是交替应用两种类型的单比特旋转：
1.  **信号旋转算符 (Signal Rotation Operator) W**: 一个绕特定轴（如X轴）的旋转，其旋转角度$\theta = -2\arccos(a)$由输入信号$a \in [-1, 1]$决定。
    $$
    W(a) = \begin{bmatrix} a & i\sqrt{1-a^2} \\ i\sqrt{1-a^2} & a \end{bmatrix}
    $$
2.  **处理旋转算符 (Signal Processing Rotation Operator) S**: 一个绕另一正交轴（如Z轴）的旋转，其旋转角度$\phi_k$是预先计算好的一组参数。
    $$
    S(\phi) = e^{i\phi Z}
    $$
通过将这两个算符以特定序列$U_{\vec{\phi}} = S(\phi_0) \prod_{k=1}^{d} W(a) S(\phi_k)$交替作用，最终得到的幺正矩阵的某个矩阵元（例如$\langle + | U_{\vec{\phi}} | + \rangle$）可以被构造成输入信号$a$的任意一个满足特定奇偶性和边界条件的多项式$\text{Poly}(a)$。

#### Block Encodings
**块编码**是一种将一个非酉的$N \times N$矩阵$A$嵌入到一个更大的酉矩阵$U$中的方法。如果$U$作用在一个更大的希尔伯特空间$\mathcal{H}_{anc} \otimes \mathcal{H}_{sys}$上，其中$\mathcal{H}_{anc}$是辅助比特空间，那么$U$被称为是$A$的一个块编码，如果：
$$
U = \begin{bmatrix} A & \cdot \\ \cdot & \cdot \end{bmatrix}
$$
或者更形式化地， $A = (\langle 0|_{anc} \otimes I_{sys}) U (|0\rangle_{anc} \otimes I_{sys})$。
这个技术是推广QSP的关键，因为它允许我们将一个矩阵（而不仅仅是一个标量$a$）作为“信号”输入到量子电路中。$A$的奇异值$\sigma_k$就扮演了信号的角色，QSVT能够对这些$\sigma_k$进行多项式变换。

#### Quantum Singular Value Transformation (QSVT)
**量子奇异值变换** (**QSVT**) 是QSP的核心思想在多比特系统中的直接推广。给定一个矩阵$A$的块编码$U_A$，QSVT能够构造一个过程，有效地实现一个新的块编码$U_{P(A)}$，其中$P(A)$是对$A$的奇异值$\sigma_k$应用某个多项式$P$的结果。具体来说，如果$A$的奇异值分解是$A = \sum_k \sigma_k |w_k\rangle\langle v_k|$，那么QSVT可以实现一个变换，其效果近似于$\sum_k P(\sigma_k) |w_k\rangle\langle v_k|$。
这是通过交替应用$U_A$和在辅助比特子空间上由投影算符控制的相移门来实现的，这完全模拟了QSP中交替应用$W(a)$和$S(\phi)$的过程。QSVT是连接所有这些算法的中心枢纽。

### 主要数学记号及其定义
-   $W(a)$: 信号旋转算符，是信号$a$的函数。
-   $S(\phi)$: 处理旋转算符，由相位$\phi$参数化。
-   $\vec{\phi} = (\phi_0, \phi_1, \dots, \phi_d)$: QSP中的相位角序列。
-   $U_{\vec{\phi}}$: 完整的QSP幺正序列。
-   $\text{Poly}(a)$: 由QSP实现的关于$a$的多项式。
-   $A, H$: 分别表示一般的（可能是非厄米的）矩阵和哈密顿量（厄米矩阵）。
-   $U_A$: 矩阵$A$的块编码幺正算符。
-   $\Pi, \tilde{\Pi}$: 投影算符，用于定义块编码并实现受控相移。
-   $\sigma_k, \lambda_k$: 分别表示矩阵的奇异值和特征值。
-   $\text{Poly}^{(\text{SV})}(A)$: 对矩阵$A$进行奇异值多项式变换后的结果。
-   $P^{\text{ET}}_{\epsilon,\Delta,\lambda_{\text{th}}/\alpha}(x)$: 特征值阈值多项式，用于区分特征值是否在阈值之上或之下。
-   $P^{\text{PE}}_{\epsilon,\Delta}(x)$: 相位估计多项式。
-   $P^{\text{MI}}_{\epsilon,\kappa}(x)$: 矩阵求逆多项式。

### 研究方法和核心创意
-   **研究方法**: 本文采用的是一种**理论框架构建**和**综合评述** (synthesis and review) 的方法。它不是提出一个全新的、解决特定问题的算法，而是基于一个新近发展的强大工具(QSVT)，系统性地重构和统一已有的知识体系。它将看似孤立的算法（搜索、相位估计、模拟）置于一个共同的数学基础上，从而揭示它们内在的联系。
-   **核心创意**: 核心创意在于认识到，**对（奇异）值进行多项式函数变换是许多量子算法加速能力的本质**。QSVT就是实现这种变换的通用引擎。一旦拥有了这个引擎，设计一个算法就变成了两个相对独立的、更简单的问题：
    1.  **编码问题**: 如何将问题的关键参数（如搜索问题中的交叠振幅，哈密顿量模拟中的能量特征值）编码为一个矩阵的奇异值，并构造这个矩阵的块编码。
    2.  **函数问题**: 需要设计一个什么样的目标多项式函数（如近似符号函数、三角函数等）来作用于这些奇异值，以达到解决问题的目的。
-   **创新点评价**: 这个创意是革命性的。它将算法设计从“寻找巧妙的酉算符序列”的“艺术创作”过程，转变为一个更具系统性的“工程设计”过程。这种视角不仅统一了现有算法，还极大地简化了新算法的设计，并能直接给出最优的复杂度界。
-   **适用领域**: 该框架适用于所有可以被表述为对一个可块编码矩阵的奇异值/特征值进行函数变换的问题。这涵盖了目前绝大多数重要的量子算法。

### 公式推导
文章的核心推导链条是将单比特QSP推广到QSVT。

1.  **从QSP到振幅放大 (Theorem 2)**:
    -   **假设**: 有一个幺正算符$U$和两个态$|A_0\rangle, |B_0\rangle$，它们的交叠$a = \langle A_0|U|B_0\rangle$很小。
    -   **推导**: 作者指出，在由$\{|A_0\rangle, |A_1\rangle\}$和$\{|B_0\rangle, |B_1\rangle\}$（其中$|A_1\rangle, |B_1\rangle$是正交补空间中的态）张成的两个二维子空间（两个“Bloch球”）中，算符$U$的作用等效于一个旋转矩阵$R(a)$。
    -   通过交替应用$U$、反射算符$A_\phi = e^{i\phi|A_0\rangle\langle A_0|}$和$B_\phi = e^{i\phi|B_0\rangle\langle B_0|}$，整个序列在二维子空间上的作用完全等同于单比特的QSP过程。因此，最终的振幅$\langle A_0 | \text{Circuit} | B_0 \rangle$可以被构造成$a$的多项式。

2.  **从振幅放大到特征值变换 (Theorem 3)**:
    -   **假设**: 有一个哈密顿量$H = \sum_\lambda \lambda |\lambda\rangle\langle\lambda|$被块编码在幺正算符$U$中。
    -   **推导**: 在$H$的每个本征子空间$|\lambda\rangle$中，$U$的作用都像一个独立的二维旋转，旋转角度由特征值$\lambda$决定，即$U = \bigoplus_\lambda R(\lambda) \otimes |\lambda\rangle\langle\lambda|$。
    -   现在，用投影算符$\Pi$控制的相移门代替了振幅放大中的反射算符$A_\phi$和$B_\phi$。这个过程相当于在每个本征子空间上**并行地**执行独立的QSP。
    -   因此，整个过程实现了一个算符$\text{Poly}(H) = \sum_\lambda \text{Poly}(\lambda) |\lambda\rangle\langle\lambda|$，即对所有特征值同时进行了多项式变换。

3.  **从特征值变换到奇异值变换 (Theorem 4)**:
    -   **假设**: 一个通用矩阵$A = \sum_k \sigma_k |w_k\rangle\langle v_k|$被块编码在$U$中。
    -   **推导**: 与特征值变换类似，对于每一对左右奇异向量$(|w_k\rangle, |v_k\rangle)$，$U$的作用也像一个二维旋转，角度由奇异值$\sigma_k$决定。不同之处在于，这个旋转连接了两个不同的子空间（左奇异空间和右奇异空间）。
    -   通过交替应用$U$以及分别作用于左、右奇异空间的受控相移门（由投影$\Pi$和$\tilde{\Pi}$控制），同样可以在每个奇异值对应的二维子空间上并行执行QSP。
    -   最终结果是对奇异值实现了多项式变换，即QSVT。

### 图表
-   **Fig. 1**: 展示了QSP（BB1脉冲序列）相比于简单的旋转，可以在更宽的信号范围（$\theta$）内保持输出概率接近1，体现了QSP塑造函数响应的能力。
-   **Fig. 2**: 振幅放大的几何图像。它显示了在Bloch球上，如何通过关于$|A_0\rangle$和$|B_0\rangle$的旋转，将初始态$U|B_0\rangle$逐步旋转到目标态$|A_0\rangle$。
-   **Fig. 3**: 实现投影受控相移$\Pi_\phi$的电路。这是将QSP推广到高维系统的基本门。
-   **Fig. 4 & 5**: 块编码的电路表示。Fig. 4展示了最简单的受控酉算符块编码。Fig. 5展示了如何利用受控SWAP门构造一个更通用的块编码。
-   **Fig. 6**: 符号函数$\Theta(x)$及其多项式近似$P_{\epsilon,\Delta}(x)$的图像。展示了在中心区域$\Delta$之外，多项式如何以$\epsilon$的精度逼近符号函数，这是实现搜索算法的关键。
-   **Fig. 7-8**: 用于特征值阈值问题的电路。Fig. 7展示了如何构造$\frac{1}{2}(H/\alpha+I)$的块编码。Fig. 8展示了利用这个块编码和QSVT来判断是否存在低于阈值的特征值。
-   **Fig. 9-12**: 相位估计算法的电路图。Fig. 10展示了核心矩阵$A_j(\theta)$的块编码电路。Fig. 11是算法的抽象概览，显示了迭代和信息前馈的结构。Fig. 12是完整的、详细的电路图，揭示了其与逆QFT的深层联系。
-   **Fig. 13-16**: 展示了相位估计算法如何逐步简化并最终演变为标准逆量子傅里叶变换电路的过程。这个过程清晰地揭示了QSVT是QFT的一种推广。
-   **Fig. 17**: 用于哈密顿量模拟的电路。展示了如何将$\cos(Ht)$和$-i\sin(Ht)$的QSVT块组合起来，以构造$e^{-iHt}$的近似。
-   **Fig. 18**: A-region的图形化表示，用于分析相位估计算法中的误差。
-   **Fig. 19-31**: 附录中的各种函数（如矩阵求逆的$1/x$、三角函数、阈值函数、ReLU函数等）及其多项式近似的响应曲线图，为实际应用QSVT提供了具体的函数形状和参数。

## 点评

### 缺点和展望
-   **挑战既有知识**: 本文极大地挑战了“量子算法是各自独立的巧妙构造”这一传统认知。它提供了一个统一的视角，将算法设计模块化、系统化。
-   **进一步的问题**:
    1.  **块编码的成本**: 文章的核心假设是能够获得所需矩阵的块编码。然而，构造一个块编码本身可能是一个复杂且资源消耗巨大的过程。QSVT算法的整体复杂度严重依赖于块编码的实现成本。这是一个主要的开放性问题和实际应用的瓶颈。
    2.  **非结构化问题**: 正如作者在第七节讨论中指出的，对于存储在QRAM中的一般性、非结构化矩阵，QSVT虽然能工作，但其相对于经典采样算法的优势可能只是多项式的，而非指数的。QSVT的最大威力体现在处理具有特殊结构（如稀疏性、可高效模拟）的矩阵时。
    3.  **与其他算法的统一**: 作者提到，变分量子算法（VQE、QAOA）等尚未被纳入QSVT框架。能否将这些混合量子-经典算法也用QSVT的语言来描述或增强，是一个有趣的展望。

-   **不合理的假设**: 主要的待推广假设就是“块编码预言机是给定的”。在实际问题中，我们需要具体问题具体分析如何高效地构建这个预言机。

### 关联
-   **与其它文献的联系**:
    -   本文是对 **Gilyén, Su, Low, and Wiebe (GSLW'19)** [12] 的开创性工作的教学性阐述和推广。GSLW'19首次正式提出了QSVT并展示了其广泛应用，本文则以更易于理解的方式重构了其中的核心思想和算法。
    -   它直接联系并推广了**Low and Chuang**关于QSP和qubitization的工作[7, 8]，这些是QSVT的技术基础。
    -   它重构并改进了**Harrow, Hassidim, Lloyd (HHL)** 算法[15]，通过QSVT实现矩阵求逆，在条件数$\kappa$和精度$\epsilon$的依赖性上获得了更好的扩展性。
    -   它提供了一个对**Grover搜索**[4]和**Kitaev相位估计**[20, 43]的全新理解，将它们看作是QSVT对特定多项式（符号函数和阈值函数）的应用。
-   **对当前研究的联系**: 如果你正在研究任何涉及哈密顿量模拟、量子线性代数或设计新量子算法的领域，QSVT提供了一个最前沿、最强大的设计工具。它告诉你，你的问题可以归结为找到一个合适的块编码和一个合适的多项式。这大大简化了算法的设计和分析。

## 反思

### 灵感来源
作者的灵感来源可以归结为以下几点：

1.  **抓住核心突破**: 作者敏锐地意识到了GSLW'19论文中提出的QSVT不仅仅是另一个算法，而是一个具有统一能力的**范式转变**。他们的灵感来自于将这一复杂的、高度技术性的突破性成果，以一种教学法的方式（pedagogical）呈现给更广泛的科研群体。
2.  **深刻的物理直觉**: 将高维矩阵的奇异值/特征值类比于单比特旋转中的信号参数$a$，这是一个深刻的物理洞察。这种从简单系统到复杂系统的类比和推广（QSP -> QET -> QSVT）是贯穿全文的灵感主线。
3.  **跨学科的理解**: QSVT的根源QSP来自于核磁共振（NMR）领域的复合脉冲技术。作者（特别是庄院士）在该领域有深厚的背景。这种将实验物理中的控制技术与理论计算机科学中的算法设计联系起来的跨学科视角，是产生这种统一框架的沃土。
4.  **对根本问题的追问**: 作者没有停留在“如何解决搜索问题”或“如何做模拟”，而是追问“这些成功的量子算法背后共同的数学结构是什么？”。正是对这个更根本问题的思考，引导他们走向了“大统一”的道路。

### 自己提出的问题和假设
-   **问题1**: 块编码的物理实现是否存在一个通用的“编译器”？即给定一个以某种形式描述的矩阵$A$，能否自动生成实现其块编码的有效量子电路？其资源消耗与$A$的哪些性质（如稀疏度、秩）有关？
-   **猜想1**: 所有能提供指数级量子加速的算法，其核心都在于解决了一个“结构化”的函数评估问题。即，被块编码的矩阵$A$必须具有某种经典计算机难以利用的简洁描述或结构，从而使得块编码的构建成本远低于直接处理经典矩阵的成本。
-   **问题2**: QSVT框架中的多项式是由一组相位角$\vec{\phi}$唯一确定的。这些相位角的计算是在经典计算机上完成的。这个经典计算过程的稳定性和效率如何？是否存在一些目标函数，其对应的相位角序列对噪声和误差极其敏感？
-   **问题3**: 能否将QSVT的思想应用于量子纠错？例如，将错误综合症（syndrome）看作信号，设计一个多项式变换来更鲁棒地识别和纠正错误。

### 其他问题
-   **为什么感兴趣**: 这篇文章极其重要，因为它提供了一种“第一性原理”式的理解量子算法的方式。它将量子算法设计从一系列“孤立的天才闪光”变成了一门可以系统学习和应用的“工程学科”，是理解现代量子算法理论的必经之路。
-   **结论与认知**: 本文的结论极大地**刷新**了对量子算法的传统认知，但与领域内的最新进展是**相符**的。它代表了量子算法理论从“第二代”（以QFT、Grover为代表）向“第三代”（以QSVT为核心框架）的演进。
-   **[[英语\|英语]]表达**:
    -   "The strongest arguments for this advantage are **borne by** algorithms for..." (这种优势最有力的论据来自于...)
    -   "A number of these quantum algorithms have recently been **tied together by** a novel technique..." (许多算法最近被一种新技术联系起来...)
    -   "...from which the QSVT **naturally emerges**." (...QSVT由此自然地引出。)
    -   "This overview illustrates how the QSVT is a single framework **comprising** the three major quantum algorithms, suggesting a **grand unification** of quantum algorithms." (这篇综述阐明了QSVT如何成为一个包含三大主要算法的单一框架，从而提出了算法的大统一。)
-   **令人费解的语句**: 作为一篇教程，这篇文章写得非常清晰。主要的难点在于其数学的抽象性，而非语言的晦涩。对于初学者，从单比特QSP（Sec. II.A）到多比特QSVT（Sec. II.D）的逻辑跳跃可能需要反复阅读和思考，特别是对块编码概念的理解是关键。但文章本身已经尽力通过振幅放大的例子来铺垫这个跳跃，使其尽可能平滑。